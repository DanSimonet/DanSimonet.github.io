<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Fundamentals</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Fundamentals</h1>

</div>


<pre><code>## -- Attaching packages ---------------------------------- tidyverse 1.2.1 --</code></pre>
<pre><code>## v ggplot2 3.1.0       v purrr   0.3.2  
## v tibble  2.1.1       v dplyr   0.8.0.1
## v tidyr   0.8.3       v stringr 1.4.0  
## v readr   1.3.1       v forcats 0.4.0</code></pre>
<pre><code>## -- Conflicts ------------------------------------- tidyverse_conflicts() --
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()</code></pre>
<p>As in any language, you need to understand the grammar and syntax to effectiely speak. Similarly, the key to a programming languages is understanding how data are stored and manipulated. Basic data types are things you will <strong>manipulate on a day-to-day basis</strong> in R. Differences in how they work is among the most common source of frustration among beginners and is key to getting the most out of the experience.</p>
<p>The next set of sections will teach you the basic’s of R’s object types along with how to store, retrieve, and change data values. We will also diver deeper into base R functions and practice making your own functions and loops. Along the way you will build a deck of 52 playing cards. When finished, your deck will look something like this:</p>
<pre class="sourceCode r"><code class="sourceCode r"> face   suit value
 king hearts    <span class="dv">13</span>
queen hearts    <span class="dv">12</span>
 jack hearts    <span class="dv">11</span>
  ten hearts    <span class="dv">10</span>
 nine hearts     <span class="dv">9</span>
eight hearts     <span class="dv">8</span>
...</code></pre>
<p>We will provide other contrived examples as well as illustrate concepts using the <code>Cars93</code>, <code>ChickenWeight</code>, and <code>msleep</code> datasets. Together, this chapter will work your way through many fundamental concepts in the R language.</p>
<div id="r-objects" class="section level2">
<h2>R Objects</h2>
<p>What is an object? An object is a thing – like a number, a dataset, a summary statistic like a mean or standard deviation, or a statistical test. R Objects come in many different shapes and sizes. There are simple objects like vectors (like our <code>die</code> and ‘heights’ examples earlier) which represent one or more numbers, more complex objects like dataframes which represent tables of data, and even more complex objects like hypothesis tests or regression which contain all sorts of statistical information.</p>
<p>Different types of objects have different <strong>attributes</strong>. For example, a matrix has a <code>dim</code> attribute (i.e., number of rows and columns) while a data set with variable headers has a <code>names</code> attribute. Don’t worry if this is a bit confusing now – it will all become clearer when you meet these new objects in later sections. Just know that objects in R are things, and different objects have different attributes.</p>
<div id="atomic-vectors" class="section level3">
<h3>Atomic Vectors</h3>
<center>
<img src="Figures/scalar_vectors.png" width="200" />
</center>
<p><br></p>
<p>Perhaps the simplest object in R is an <strong>atomic vector</strong>, a one-dimensional object containing a single type of data. You can think of this like an excel column. In fact, our <code>die</code> object from the first section is a vector with six elements. You can create atomic vectors by grouping data values together with <code>c</code></p>
<pre class="r"><code>die &lt;- c(1, 2, 3, 4, 5, 6)
die</code></pre>
<pre><code>## [1] 1 2 3 4 5 6</code></pre>
<p>A <strong>scalar</strong> is a special instance of a vector with just one element of data, such as a single name or number.</p>
<pre class="r"><code># Examples of scalars
a &lt;- 100
b &lt;- 2 / 100
c &lt;- (a + b) / b
a; b; c</code></pre>
<pre><code>## [1] 100</code></pre>
<pre><code>## [1] 0.02</code></pre>
<pre><code>## [1] 5001</code></pre>
<p>You can save different types of data in R by using different types of atomic vectors. Altogether, R recognizes six basic types of atomic vectors: <em>doubles/numeric</em>, <em>integers</em>, <em>characters</em>, <em>logicals</em>, <em>complex</em>, and <em>raw</em>.</p>
<center>
<img src="Figures/atomic_vectors.png" width="500" />
</center>
<p><br></p>
<p>To create a card deck, you will need to use different types of atomic vectors to store different kinds of information (text and numbers). Different data types call for different data entry conventions (see picture above). For example, you create integer vectors by including a capital L with your input. You can create a character vector by surrounding inputs in quotation marks:</p>
<pre class="r"><code>integers &lt;- c(1L, 5L)
text &lt;- c(&quot;ace&quot;, &quot;five&quot;)</code></pre>
<p>Vector types help R behave as you would expect. For example, R will do math with atomic vectors containing numbers, but not atomic vectors containing character strings:</p>
<pre class="r"><code>sum(integers)     #this is okay
sum(text)    #this will not work</code></pre>
<p>For our purposes we restrict discussion to the most commonly used vector types: <strong>doubles</strong> (i.e., numeric), <strong>character</strong>, and <strong>logical</strong>.</p>
<div id="doubles" class="section level4">
<h4>Doubles</h4>
<p>A double vector stores regular numbers. These numbers can be positive or negative, large or small, and have digits to the right of the decimal place. You can check how many distinct elements (i.e., numbers, words) are in a vector using the <code>length()</code> function. For instance, the vector <code>c(1,2,3)</code> has a <code>length</code> of 3.</p>
<p>In general, R saves any number you enter as double. This can be verified using the <code>typeof</code> function. For example</p>
<pre class="r"><code>typeof(c(1,2,3))</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<pre class="r"><code>typeof(die)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<p>Some R functions and most users refer to doubles as numeric. Double is a computer science terms referring to the number of bytes your computer uses to store a number. In fact, if you ask R what <code>class</code> this vector belongs to it will return numeric rather than double.</p>
<pre class="r"><code>class(c(1,2,3))</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<p>The distinctions between <code>typeof</code> and <code>class</code> are nuanced and will be revisited in the <em>attributes</em> section. For now and henceforth, we will refer to these data types as numeric.</p>
</div>
<div id="characters" class="section level4">
<h4>Characters</h4>
<p>A character vector stores small pieces of text. You can create a character vector in R by typing a character or string of characters surrounded by quotes:</p>
<pre class="r"><code>text &lt;- c(&quot;Hello&quot;,  &quot;World&quot;)
text</code></pre>
<pre><code>## [1] &quot;Hello&quot; &quot;World&quot;</code></pre>
<pre class="r"><code>typeof(text)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>typeof(&quot;Hello&quot;)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p>You can combine different strings into a single string using <code>paste()</code> It can take any number of strings as well as an optional <code>sep</code> argument specifying how to seperate the strings. For example</p>
<pre class="r"><code>t1 &lt;- &quot;Hello&quot;
t2 &lt;- &quot;how&quot;
t3 &lt;- &quot;are you?&quot;

paste(t1, t2, t3)</code></pre>
<pre><code>## [1] &quot;Hello how are you?&quot;</code></pre>
<pre class="r"><code>paste(t1, t2, t3, sep = &quot;-&quot;)</code></pre>
<pre><code>## [1] &quot;Hello-how-are you?&quot;</code></pre>
<pre class="r"><code>paste(t1, t2, t3, sep = &quot;&quot;)</code></pre>
<pre><code>## [1] &quot;Hellohoware you?&quot;</code></pre>
<p>Notice there is still a space between “are” and “you” in the last example. This is because R treats <code>t3</code> as a <strong>single</strong> string rather than two different words. Compare to the following:</p>
<pre class="r"><code>t1 &lt;- &quot;Hello&quot;
t2 &lt;- &quot;how&quot;
t3 &lt;- &quot;are&quot;
t4 &lt;- &quot;you?&quot;

paste(t1, t2, t3, t4, sep = &quot;&quot;)</code></pre>
<pre><code>## [1] &quot;Hellohowareyou?&quot;</code></pre>
<p>A string can contain more than just letters. You can assemble character strings from numbers or symbols as well. For instance, the vector <code>1</code> is numeric but the vector <code>"1"</code> is a character. You can tell strings from real numbers because strings are surrounded by quotes.</p>
<p>A common error when first using R is to omit a quote when entering string data. Expect an error as R will start looking for a non-existent object.</p>
<pre class="r"><code>c(&quot;King&quot;, &quot;Queen, &quot;Jack&quot;)</code></pre>
</div>
<div id="logical" class="section level4">
<h4>Logical</h4>
<p>Logical vectors stores <code>TRUES</code>s and <code>FALSE</code>s, R’s form of Boolean data. Logicals are <strong>very helpful</strong> for doing comparisons and subsetting data, a topic we visit later. For example:</p>
<pre class="r"><code>3 &gt; 4              #Is 3 greater than 4?</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>c(1, 2) &gt; c(3, 4)  #Is 1 greater than 3 and is 2 greater than 4?</code></pre>
<pre><code>## [1] FALSE FALSE</code></pre>
<p>Any time you type <code>TRUE</code> or <code>FALSE</code> in capital letters (without quotations), R will treat your input as logical data. R also assumes <code>T</code> and <code>F</code> are shorthand for <code>TRUE</code> and <code>FALSE</code>, unless they are defined elsewhere (e.g., <code>T &lt;- 500</code>). Since the meaning of <code>T</code> and <code>F</code> can change, its best to stick with <code>TRUE</code> and <code>FALSE</code>.</p>
<pre class="r"><code>logic &lt;- c(TRUE, FALSE, TRUE)
logic</code></pre>
<pre><code>## [1]  TRUE FALSE  TRUE</code></pre>
<pre class="r"><code>typeof(logic)</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<pre class="r"><code>typeof(F)</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
</div>
<div id="exercise---create-a-royal-flush" class="section level4">
<h4>Exercise - Create a Royal Flush</h4>
<ol style="list-style-type: decimal">
<li>Create 3 different atomic vectors containing the face value, suit, and numerical values (consider ace low) of a royal flush, such as the ace, king, queen, jack, and ten of hearts. The face vector can contain the card rank (e.g., king), suit vector contain different groups (e.g., heart), and value corresponds to points (e.g., king 13, ace 1).</li>
</ol>
<pre class="r"><code>face &lt;- c(&quot;ace&quot;, &quot;king&quot;, &quot;queen&quot;, &quot;jack&quot;, &quot;ten&quot;)        # character vector
suit &lt;- c(&quot;heart&quot;, &quot;heart&quot;, &quot;heart&quot;, &quot;heart&quot;, &quot;heart&quot;)  # character vector
value &lt;- c(1, 13, 12, 11, 10)                           # numeric vector
face; suit; value                                       # Note: the ; allows you to execute multiple commands on the same line</code></pre>
<pre><code>## [1] &quot;ace&quot;   &quot;king&quot;  &quot;queen&quot; &quot;jack&quot;  &quot;ten&quot;</code></pre>
<pre><code>## [1] &quot;heart&quot; &quot;heart&quot; &quot;heart&quot; &quot;heart&quot; &quot;heart&quot;</code></pre>
<pre><code>## [1]  1 13 12 11 10</code></pre>
<p>Whew that was a lot of work. It would be time consuming to make a whole deck of cards this way. If only there was a faster way?</p>
</div>
</div>
</div>
<div id="creating-vectors" class="section level2">
<h2>Creating Vectors</h2>
<p>Vectors can contain any number of elements. For instance, the numbers from one to ten could be a vector of length 10, and the characters in the English alphabet could be a vector of length 26. There are many ways to create vectors in R, some of which we’ve covered. Below are some commonly used functions to create vectors.</p>
<table>
<colgroup>
<col width="38%" />
<col width="44%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Example</th>
<th align="left">Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>c(a, b, ...)</code></td>
<td align="left"><code>c(1, 5, 9)</code></td>
<td align="left">1, 5, 9</td>
</tr>
<tr class="even">
<td align="left"><code>a:b</code></td>
<td align="left"><code>1:5</code></td>
<td align="left">1, 2, 3, 4, 5</td>
</tr>
<tr class="odd">
<td align="left"><code>seq(from, to, by, length.out)</code></td>
<td align="left"><code>seq(from = 0, to = 6, by = 2)</code></td>
<td align="left">0, 2, 4, 6</td>
</tr>
<tr class="even">
<td align="left"><code>rep(x, times, each, length.out)</code></td>
<td align="left"><code>rep(c(7, 8), times = 2, each = 2)</code></td>
<td align="left">7, 7, 8, 8, 7, 7, 8, 8</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>The simplest way to create a vector is with the <code>c()</code> function which we’ve already used several times. The <code>c</code> stands for concatenate, which means “bring them together”. The <code>c()</code> function takes several scalars as arguments, and returns a vector containing those objects. When using <code>c()</code>, place a comma in between the objects (scalars or vectors) you want to combine.</p>
<p>Let’s use the <code>c()</code> function to create a vector called <code>a</code> containing numbers from 1 to 5.</p>
<pre class="r"><code># Create object a with numbers from 1 to 5
a &lt;- c(1, 2, 3, 4, 5)
a</code></pre>
<pre><code>## [1] 1 2 3 4 5</code></pre>
<p>You can create longer vectors by combining vectors you have already defined. For instance, we can create a vector from 1 to 10 called <code>x</code> by combining a smaller vector <code>a</code> from 1 to 5 with a vector <code>b</code> from 6 to 10.</p>
<pre class="r"><code>a &lt;- c(1, 2, 3, 4, 5)
b &lt;- c(6, 7, 8, 9, 10)
x &lt;- c(a, b)
x</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<p>You can duplicate vectors or interweave other numbers.</p>
<pre class="r"><code>c(a, a)</code></pre>
<pre><code>##  [1] 1 2 3 4 5 1 2 3 4 5</code></pre>
<pre class="r"><code>c(a, 100, 100, 100, b, 100, 100)</code></pre>
<pre><code>##  [1]   1   2   3   4   5 100 100 100   6   7   8   9  10 100 100</code></pre>
<p>Finally, creating vectors using <code>c()</code> function works the same way with elements of different data types.</p>
<pre class="r"><code>c(TRUE, FALSE, TRUE)</code></pre>
<pre><code>## [1]  TRUE FALSE  TRUE</code></pre>
<pre class="r"><code>c(&quot;Serena&quot;, &quot;June&quot;, &quot;Nick&quot;, &quot;Fred&quot;)</code></pre>
<pre><code>## [1] &quot;Serena&quot; &quot;June&quot;   &quot;Nick&quot;   &quot;Fred&quot;</code></pre>
<p>While the <code>c()</code> is straighforward, it is not always efficient. Say you wanted to create participant ids from 1 to 100. You definitely don’t want to type all the numbers into a <code>c()</code> operator. Thankfully, R has many built-in functions for generating numeric vectors. We will explore three of them: <code>a:b</code>, <code>seq()</code>, and <code>rep()</code>.</p>
<div id="ab" class="section level3">
<h3>a:b</h3>
<p>The <code>a:b</code> function takes two numeric scalars <code>a</code> and <code>b</code> as arguments, and returns a vector of numbers from the starting point <code>a</code> to the ending point <code>b</code> in steps of 1. Here are some examples of the <code>a:b</code> function in action. You can go backwards or forwards, or make sequences between non-integers.</p>
<pre class="r"><code>1:5</code></pre>
<pre><code>## [1] 1 2 3 4 5</code></pre>
<pre class="r"><code>5:1</code></pre>
<pre><code>## [1] 5 4 3 2 1</code></pre>
<pre class="r"><code>-1:-5</code></pre>
<pre><code>## [1] -1 -2 -3 -4 -5</code></pre>
<pre class="r"><code>2.77:8.77</code></pre>
<pre><code>## [1] 2.77 3.77 4.77 5.77 6.77 7.77 8.77</code></pre>
</div>
<div id="seq" class="section level3">
<h3>seq()</h3>
<table>
<colgroup>
<col width="46%" />
<col width="53%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Argument</th>
<th align="left">Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>from</code></td>
<td align="left">The start of the sequence</td>
</tr>
<tr class="even">
<td align="left"><code>to</code></td>
<td align="left">The end of the sequence</td>
</tr>
<tr class="odd">
<td align="left"><code>by</code></td>
<td align="left">The step-size of the sequence</td>
</tr>
<tr class="even">
<td align="left"><code>length.out</code></td>
<td align="left">The desired length of the final sequence (only use if you don’t specify <code>by</code>)</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>The <code>seq()</code> is a more flexible cousin of <code>a:b</code>. Like <code>a:b</code>, <code>seq()</code> allows you to create a sequence from a starting number to an ending number. However, <code>seq()</code> has two additional arguments: <code>by</code> which allows you to specify the size of the spaces between numbers or <code>length.out</code> specifying the length of the final sequence.</p>
<p>If you use the <code>by</code> argument, the sequence will be in steps of input to the <code>by</code> argument</p>
<pre class="r"><code># Create numbers from 1 to 10 in steps of 1. Note this is equivalent to 1:10
seq(from = 1, to = 10, by = 1)</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<pre class="r"><code># Integers from 0 to 100 in steps of 10
seq(from = 1, to = 100, by = 10)</code></pre>
<pre><code>##  [1]  1 11 21 31 41 51 61 71 81 91</code></pre>
<pre class="r"><code># Reversed - must add negative sign to by argument
seq(from = 100, to = 1, by = -5)</code></pre>
<pre><code>##  [1] 100  95  90  85  80  75  70  65  60  55  50  45  40  35  30  25  20
## [18]  15  10   5</code></pre>
<p>Suppose we don’t know the increment value for <code>by</code>, but we want some evenly distributed numbers of predefined length. This is where <code>length.out</code> argument comes into play.</p>
<pre class="r"><code># Create 5 numbers from 0 to 20
seq(from = 0, to = 20, length.out = 5)</code></pre>
<pre><code>## [1]  0  5 10 15 20</code></pre>
<pre class="r"><code># Create 3 numbers from 0 to 100
seq(from = 0, to = 100, length.out = 3)</code></pre>
<pre><code>## [1]   0  50 100</code></pre>
<pre class="r"><code># Works for fractional increments as well, such as creating 10 numbers from 1 to 5
seq(from = 0, to = 5, length.out = 10)</code></pre>
<pre><code>##  [1] 0.0000000 0.5555556 1.1111111 1.6666667 2.2222222 2.7777778 3.3333333
##  [8] 3.8888889 4.4444444 5.0000000</code></pre>
</div>
<div id="rep" class="section level3">
<h3>rep()</h3>
<table>
<thead>
<tr class="header">
<th align="left">Argument</th>
<th align="left">Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x</code></td>
<td align="left">A scalar or vector of values to repeat</td>
</tr>
<tr class="even">
<td align="left"><code>times</code></td>
<td align="left">The number of times to repeat x</td>
</tr>
<tr class="odd">
<td align="left"><code>each</code></td>
<td align="left">The number of times to repeat each value within x</td>
</tr>
<tr class="even">
<td align="left"><code>length.out</code></td>
<td align="left">The desired length of the final sequence</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>The <code>rep()</code> function allows you to repeat a scalar (or vector) a specified number of times, or to a desired length. You can think of <code>times</code> as indicating how often to repeat the <strong>vector</strong> itself whereas <code>each</code> gives the number of times you wish to repeat each <strong>element</strong> within the vector. This is more easily shown with a few examples.</p>
<pre class="r"><code># Take the scalar 1 and repeat it 3 times
rep(x = 1, times = 3)</code></pre>
<pre><code>## [1] 1 1 1</code></pre>
<pre class="r"><code># Take the vector (1,2) and repeat it 3 times
rep(x = c(1, 2), times = 3)</code></pre>
<pre><code>## [1] 1 2 1 2 1 2</code></pre>
<pre class="r"><code># Repeat the character vector c(&quot;male&quot;, &quot;female&quot;) 3 times
rep(c(&quot;Male&quot;,&quot;Female&quot;), times = 3)</code></pre>
<pre><code>## [1] &quot;Male&quot;   &quot;Female&quot; &quot;Male&quot;   &quot;Female&quot; &quot;Male&quot;   &quot;Female&quot;</code></pre>
<p>Notice <code>times</code> repeats vectors exactly as they appear. Now see what happens when running <code>each</code>.</p>
<pre class="r"><code># Take the vector (1,2) and repeat 1 followed by 2 3 times
rep(x = c(1, 2), each = 3)</code></pre>
<pre><code>## [1] 1 1 1 2 2 2</code></pre>
<pre class="r"><code># Replicate Male 3 times, followed by Female 3 times
rep(c(&quot;Male&quot;, &quot;Female&quot;), each = 3)</code></pre>
<pre><code>## [1] &quot;Male&quot;   &quot;Male&quot;   &quot;Male&quot;   &quot;Female&quot; &quot;Female&quot; &quot;Female&quot;</code></pre>
<p>In this case, each element is replicated 3 times before moving onto the next element in the series.</p>
<p>You can combine the <code>times</code> and <code>each</code> arguments within a single <code>rep</code> function. For example, here’s how to create the sequence {1, 1, 2, 2, 3, 3, 1, 1, 2, 2, 3, 3} with one call to <code>rep()</code>.</p>
<pre class="r"><code>rep(1:3, each = 2, times = 3)</code></pre>
<pre><code>##  [1] 1 1 2 2 3 3 1 1 2 2 3 3 1 1 2 2 3 3</code></pre>
<p>In combination with <code>paste</code>, the <code>rep</code> function is useful for creating variable labels. For instance, say we needed to insert the labels treatment1 and treatment2 ten times into a dataset to differentiate experimental conditions. We could type this, but this becomes tedious. We can accelerate as follows:</p>
<pre class="r"><code>paste(&quot;treatment&quot;, rep(1:2, each = 10), sep = &quot;&quot;)</code></pre>
<pre><code>##  [1] &quot;treatment1&quot; &quot;treatment1&quot; &quot;treatment1&quot; &quot;treatment1&quot; &quot;treatment1&quot;
##  [6] &quot;treatment1&quot; &quot;treatment1&quot; &quot;treatment1&quot; &quot;treatment1&quot; &quot;treatment1&quot;
## [11] &quot;treatment2&quot; &quot;treatment2&quot; &quot;treatment2&quot; &quot;treatment2&quot; &quot;treatment2&quot;
## [16] &quot;treatment2&quot; &quot;treatment2&quot; &quot;treatment2&quot; &quot;treatment2&quot; &quot;treatment2&quot;</code></pre>
</div>
<div id="exercise---working-with-vectors-to-build-a-deck-of-cards" class="section level3">
<h3>Exercise - Working with Vectors to Build a Deck of Cards</h3>
<ol style="list-style-type: decimal">
<li>Create vector <code>x1</code> as 1 to 5 and vector <code>x2</code> as 6 to 10. Then, combine vector <code>x1</code> and <code>x2</code>.</li>
<li>Create the vector [0, 5, 10, 15] in two ways: using <code>c()</code> and the <code>seq()</code> with a <code>by</code> argument.</li>
<li>Use <code>rep</code> to create the three following vectors, each having 52 elements:</li>
</ol>
<ul>
<li><code>value</code> vector representing the numerical values of the cards from 1 to 13, repeated 4 times</li>
<li><code>suit</code> vector representing the four classes of cards (e.g., hearts), each repeated 13 times</li>
<li><code>face</code> vector representing the value appearing on each card from lowest (ace) to highest (king), repeated 4 times</li>
</ul>
<p>Note: check your answers to the 3rd question with the <code>length</code> function. This will tell you how many elements are in each vector. In this case, all three card vectors should have a length of 52.</p>
</div>
<div id="solution" class="section level3">
<h3>Solution</h3>
<pre class="r"><code>#First problem

x1 &lt;- 1:5
x2 &lt;- 6:10
c(x1, x2)</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<pre class="r"><code>#Second problem

x &lt;- c(0, 5, 10, 15)
y &lt;- seq(from = 0, to = 15, by = 5)
x; y</code></pre>
<pre><code>## [1]  0  5 10 15</code></pre>
<pre><code>## [1]  0  5 10 15</code></pre>
<pre class="r"><code>#Third problem

value &lt;- rep(1:13, times = 4)
suit &lt;- rep(c(&quot;hearts&quot;, &quot;diamonds&quot;, &quot;clubs&quot;, &quot;spades&quot;), each = 13)
char &lt;- c(&quot;ace&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;ten&quot;, &quot;jack&quot;, &quot;queen&quot;, &quot;king&quot;)
face &lt;- rep(char, times = 4)</code></pre>
</div>
</div>
<div id="simulate-random-data" class="section level2">
<h2>Simulate Random Data</h2>
<p>As a language for statistical analysis, R carries functions for generating random data – either from a vector of data (like how we sampled <code>die</code> rolls), or from an established <strong>probability distribution</strong>, like the Normal, Binomial, or Uniform distribution. Rather than create your own values, R can <strong>generate</strong> data given certain parameters (Mean, SD) or <strong>randomly sample</strong> values from a larger set.</p>
<p>This serves many purposes. First, you can emulte other’s work using published results to create data with the same properties. This allows evaluation and replication of other’s models. Two, simulations can be used to advance psychological theories. Much like climate models, we can project what will hapen given different parameters and hypotheses and then compare these simulated results to observation. This has been done to understand many topics where conventional research strategies can be limited, including human development, complex learning, and emotional dynamics. Three, you can run monte carlo simulations to evaluate performance of different statistical estimators and determine study power. Finally, simulations can be used to help you learn. Successfully simulating data to emulate a statistical model will given you deeper intuition into the meaning and nature of your analyses.</p>
<div id="sample" class="section level3">
<h3>Sample</h3>
</div>
<div id="exercise---drawings-and-earnings" class="section level3">
<h3>Exercise - Drawings and Earnings</h3>
<ol style="list-style-type: decimal">
<li>Randomly sample</li>
</ol>
</div>
</div>
<div id="attributes" class="section level2">
<h2>Attributes</h2>
<table>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>attributes(x)</code></td>
<td align="left">Access object’s metadata</td>
</tr>
<tr class="even">
<td align="left"><code>names(x)</code></td>
<td align="left">Retrieve or set names of an R object</td>
</tr>
<tr class="odd">
<td align="left"><code>dim(x)</code></td>
<td align="left">Retrieve or set dimensions of an R object</td>
</tr>
<tr class="even">
<td align="left"><code>class(x)</code></td>
<td align="left">Class or type of object</td>
</tr>
</tbody>
</table>
<p>An attribute is a piece of information attached to an R object, including atomic vectors. Attributes won’t affect object values and are often hidden from view. You can think of an attribute as “metadata”; it is just a convenient place to put information associated with an object. R will normally ignore this metadata, but some R functions will check for specific attributes. These functions may use the attributes to do special things with the data.</p>
<p>You can view an object’s attributes with <code>attributes</code>. The <code>attributes</code> function returns <code>NULL</code> if an object has no attributes. An atomic vector, like <code>die</code>, won’t have any attributes unless you give it some:</p>
<pre class="r"><code>attributes(die)</code></pre>
<pre><code>## NULL</code></pre>
<p>R uses <code>NULL</code> to represent an empty object. <code>NULL</code> is often returned by functions whose values are undefined. You can create a <code>NULL</code> object by typing <code>NULL</code> in capital letters.</p>
<p>The most common attributes for an atomic vector are <code>names</code>, dimensions (<code>dim</code>), and <code>class</code>. You can use each of these functions to check whether objects have values for each of these attributes. We will briefly discuss each attribute in turn.</p>
<div id="names" class="section level3">
<h3>Names</h3>
<p>Names are simply labels for each element in a vector. R has a built-in data vector called <code>islands</code> providing areas for the world’s 48 largest islands in thousands of square miles. If you print <code>islands</code> to your console you will see the square mileage and, above each number, the <code>name</code> associated with the island. These can be directly accessed using the <code>names</code> function.</p>
<pre class="r"><code>names(islands)</code></pre>
<pre><code>##  [1] &quot;Africa&quot;           &quot;Antarctica&quot;       &quot;Asia&quot;            
##  [4] &quot;Australia&quot;        &quot;Axel Heiberg&quot;     &quot;Baffin&quot;          
##  [7] &quot;Banks&quot;            &quot;Borneo&quot;           &quot;Britain&quot;         
## [10] &quot;Celebes&quot;          &quot;Celon&quot;            &quot;Cuba&quot;            
## [13] &quot;Devon&quot;            &quot;Ellesmere&quot;        &quot;Europe&quot;          
## [16] &quot;Greenland&quot;        &quot;Hainan&quot;           &quot;Hispaniola&quot;      
## [19] &quot;Hokkaido&quot;         &quot;Honshu&quot;           &quot;Iceland&quot;         
## [22] &quot;Ireland&quot;          &quot;Java&quot;             &quot;Kyushu&quot;          
## [25] &quot;Luzon&quot;            &quot;Madagascar&quot;       &quot;Melville&quot;        
## [28] &quot;Mindanao&quot;         &quot;Moluccas&quot;         &quot;New Britain&quot;     
## [31] &quot;New Guinea&quot;       &quot;New Zealand (N)&quot;  &quot;New Zealand (S)&quot; 
## [34] &quot;Newfoundland&quot;     &quot;North America&quot;    &quot;Novaya Zemlya&quot;   
## [37] &quot;Prince of Wales&quot;  &quot;Sakhalin&quot;         &quot;South America&quot;   
## [40] &quot;Southampton&quot;      &quot;Spitsbergen&quot;      &quot;Sumatra&quot;         
## [43] &quot;Taiwan&quot;           &quot;Tasmania&quot;         &quot;Tierra del Fuego&quot;
## [46] &quot;Timor&quot;            &quot;Vancouver&quot;        &quot;Victoria&quot;</code></pre>
<p>What if we tried to access the <code>names</code> attribute for our <code>die</code> object?</p>
<pre class="r"><code>names(die)</code></pre>
<pre><code>## NULL</code></pre>
<p><code>NULL</code> indicates there are no names because we haven’t assigned any! You can give names to <code>die</code> by assigning a character vector to the output of <code>names</code>. Think of this as filling in <code>NULL</code> with information. Importantly, the vector should include one name for <strong>each element</strong> in <code>die</code></p>
<pre class="r"><code>names(die) &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;)</code></pre>
<p>Now <code>die</code> has a names attribute you can access, view, and manipulate.</p>
<pre class="r"><code># Directly access names
names(die)</code></pre>
<pre><code>## [1] &quot;one&quot;   &quot;two&quot;   &quot;three&quot; &quot;four&quot;  &quot;five&quot;  &quot;six&quot;</code></pre>
<pre class="r"><code># View all attributes (just names for now)
attributes(die)</code></pre>
<pre><code>## $names
## [1] &quot;one&quot;   &quot;two&quot;   &quot;three&quot; &quot;four&quot;  &quot;five&quot;  &quot;six&quot;</code></pre>
<p>Like the <code>islands</code> vector, R displays names above the numerical values of <code>die</code> whenever you print the vector.</p>
<pre class="r"><code>die</code></pre>
<pre><code>##   one   two three  four  five   six 
##     1     2     3     4     5     6</code></pre>
<p>However, as noted above, attributes <strong>do not affect the values</strong> of the vector. Hence, names won’t change the values nor will names be affected if you alter the vector’s values.</p>
<pre class="r"><code>die + 1</code></pre>
<pre><code>##   one   two three  four  five   six 
##     2     3     4     5     6     7</code></pre>
<p>You can use <code>names</code> whenever you wish to change the names attribute or if you decide to remove them all together.</p>
<pre class="r"><code># change the names of die

names(die) &lt;- c(&quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;)
die</code></pre>
<pre><code>##   I  II III  IV   V  VI 
##   1   2   3   4   5   6</code></pre>
<pre class="r"><code># Remove names attribute from die by setting to NULL
names(die) &lt;- NULL
die</code></pre>
<pre><code>## [1] 1 2 3 4 5 6</code></pre>
</div>
<div id="dim" class="section level3">
<h3>Dim</h3>
<p>So far we have only worked with one-dimensional vectors. However, most data structures - such as survey or experimental results - are stored in two-dimensional structures of rows and columns (or higher dimensions such as cubes). R handles this by assigning a <code>dim</code> attribute to vectors to transform them into an <strong>n</strong>-dimensional array. To do this, set the <code>dim</code> attribute to a numeric vector of length <em>n</em>. R will reorganize the elements of the vector into <strong>n</strong> dimensions, with each dimension having as many rows (or columns) as the as the <em>nth</em> value of the <code>dim</code> vector. For example, you could reorganize th <code>die</code> vector into a 2 x 3 matrix (2 rows by 3 columns).</p>
<pre class="r"><code>dim(die) &lt;- c(2, 3)
die</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6</code></pre>
<p>or a 3 x 2 matrix (3 rows by 2 columns)</p>
<pre class="r"><code>dim(die) &lt;- c(3, 2)
die</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6</code></pre>
<p>You can even assign the vector to a matrix with one column or row, effectively giving the vector an arbitrary dimension beyond its <code>length()</code>.</p>
<pre class="r"><code># stack vector into 1 column with 6 rows
dim(die) &lt;- c(6, 1)
die</code></pre>
<pre><code>##      [,1]
## [1,]    1
## [2,]    2
## [3,]    3
## [4,]    4
## [5,]    5
## [6,]    6</code></pre>
<pre class="r"><code># spread vector into 6 columnas with 1 row
dim(die) &lt;- c(1, 6)
die</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6]
## [1,]    1    2    3    4    5    6</code></pre>
<p>Note R will always use the the <strong>first value</strong> in <code>dim</code> for the number of rows and the <strong>second value</strong> for number of columns. In general, rows always precede columns in R operations dealing with matrices. We can spread the data out into higher dimensions, such as a hypercube with three dimensions 1 x 2 x 3. Since we often do not deal with such structures, we will focus on 2-dimensional arrays, also known as <code>matrices</code>.</p>
</div>
<div id="matrices" class="section level3">
<h3>Matrices</h3>
<table>
<colgroup>
<col width="30%" />
<col width="34%" />
<col width="34%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Description</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>matrix(x, nrow, ncol, byrow)</code></td>
<td align="left">Create a matrix from vector <code>x</code></td>
<td align="left"><code>matrix(x = 1:12, nrow = 3, ncol = 4)</code></td>
</tr>
<tr class="even">
<td align="left"><code>cbind(a, b, c)</code></td>
<td align="left">Combine vectors as columns in a matrix or dataframe</td>
<td align="left"><code>cbind(1:5, 6:10, 11:15)</code></td>
</tr>
<tr class="odd">
<td align="left"><code>rbind(a, b, c)</code></td>
<td align="left">Combine vectors as rows in a matrix or dataframe</td>
<td align="left"><code>rbind(1:5, 6:10, 11:15)</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>A <strong>matrix</strong> is a rectangular arrangement of the <strong>same type</strong> of data elements into rows and columns. Matrices form the mathematical machinery of many multivariate statistical techniques, such as factor analysis, multivariate regression, and structural equation modeling. You can do traditional matrix operations in R, such as transposition with <code>t</code>, finding a determinant with <code>det</code>, and running inner or outer multiplication with the <code>%*%</code> and `%o% operators, respectively.</p>
<p>In R, any vector with 2 dimensions automatically becomesa a matrix (see classes below) with The <code>dim</code> attribute determining size in terms of height and width. It may be easier to think of a matrix as a combination of <code>n</code> vectors, where each vector has a length of <code>m</code>. For instance, in the image below the vector has a length of 3 while the matrix is three vectors each 3 elements long (a 3 x 3 matrix).</p>
<center>
<img src="Figures/Vec_Mat.png" width="500" />
</center>
<p><br></p>
<p>The <code>matrix()</code> function creates a matrix from a single vector of data. The function has 4 main inputs: <code>data</code> - a vector of data, <code>nrow</code> - the number of rows you want in the matrix, <code>ncol</code> - the number of columns you want in the matrix, and <code>byrow</code> - a logical value indicating whether you want to fill the matrix by rows. Check the help function <code>?matrix</code> to see some additional inputs and examples.</p>
<table>
<thead>
<tr class="header">
<th align="left">Argument</th>
<th align="left">Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>data</code></td>
<td align="left">Optional data vector to be reorganized into a matrix</td>
</tr>
<tr class="even">
<td align="left"><code>nrow</code></td>
<td align="left">Desired number of rows</td>
</tr>
<tr class="odd">
<td align="left"><code>ncol</code></td>
<td align="left">Desired number of columns</td>
</tr>
<tr class="even">
<td align="left"><code>byrow</code></td>
<td align="left">Logical. If False, matrix filled by rows otherwise filled by rows</td>
</tr>
</tbody>
</table>
<pre class="r"><code>matrix(
  data = c(1:10),   # the data elements
  nrow = 2,         # the number of rows
  ncol = 5,         # the number of columns
  byrow = F,        # default argument. Fill by column
  )</code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    3    5    7    9
## [2,]    2    4    6    8   10</code></pre>
<p>We can change the above to give us 5 rows and 2 columns instead</p>
<pre class="r"><code>matrix(data = 1:10,
       nrow = 5,
       ncol = 2)</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    6
## [2,]    2    7
## [3,]    3    8
## [4,]    4    9
## [5,]    5   10</code></pre>
<p>Say we wanted to repeat above, but fill by row instead of column</p>
<pre class="r"><code>matrix(data = 1:10,
       nrow = 5,
       ncol = 2,
       byrow = TRUE)</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    2
## [2,]    3    4
## [3,]    5    6
## [4,]    7    8
## [5,]    9   10</code></pre>
<p>You can also populate a matrix with characters. However, you <em>cannot</em> mix and match numbers with words. R will coerce everything to be of a same type (more on this later).</p>
<pre class="r"><code># matrix of characters with 2 rows

matrix(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), nrow = 2)</code></pre>
<pre><code>##      [,1] [,2]
## [1,] &quot;a&quot;  &quot;c&quot; 
## [2,] &quot;b&quot;  &quot;d&quot;</code></pre>
<p><code>cbind()</code> and <code>rbind()</code> can be used to create matrices by combining several vectors of the same length. You can also use these functions to add new rows or columns of data to an existing matrix or dataframe (covered later). <code>cbind()</code> combines vectors as columns, while <code>rbind()</code> combines them as rows. Let’s use these functions to create a matrix with the numbers 1 through 30. First, we’ll create three vectors of length 5, then we’ll combine them into one matrix.</p>
<pre class="r"><code>x &lt;- 1:5
y &lt;- 6:10
z &lt;- 11:15

# create a matrix where x, y, and z are columns
cbind(x, y, z)</code></pre>
<pre><code>##      x  y  z
## [1,] 1  6 11
## [2,] 2  7 12
## [3,] 3  8 13
## [4,] 4  9 14
## [5,] 5 10 15</code></pre>
<pre class="r"><code># create a matrix where x, y, and z are rows
rbind(x, y, z)</code></pre>
<pre><code>##   [,1] [,2] [,3] [,4] [,5]
## x    1    2    3    4    5
## y    6    7    8    9   10
## z   11   12   13   14   15</code></pre>
<pre class="r"><code># Can also use to add on columns or rows to existing matrices

m &lt;- cbind(x, y, z)
xx &lt;- 16:20
cbind(m, xx)</code></pre>
<pre><code>##      x  y  z xx
## [1,] 1  6 11 16
## [2,] 2  7 12 17
## [3,] 3  8 13 18
## [4,] 4  9 14 19
## [5,] 5 10 15 20</code></pre>
<div id="exercise---build-a-matrix" class="section level4">
<h4>Exercise - Build a Matrix</h4>
<ol style="list-style-type: decimal">
<li>Create the following matrix</li>
</ol>
<pre><code>##      [,1] [,2]
## [1,]    1    3
## [2,]    2    4</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Complete the following matrix using your <code>die</code> object</li>
</ol>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6</code></pre>
<ol start="3" style="list-style-type: decimal">
<li>Create the following three of a kind matrix, which stores the name and suits of different cards</li>
</ol>
<pre><code>##      [,1]   [,2]   
## [1,] &quot;king&quot; &quot;heart&quot;
## [2,] &quot;king&quot; &quot;spade&quot;
## [3,] &quot;king&quot; &quot;club&quot;</code></pre>
<ol start="4" style="list-style-type: decimal">
<li>Use <code>cbind</code> to merge your <code>suit</code> and <code>face</code> vectors into a matrix.</li>
</ol>
</div>
<div id="solution-1" class="section level4">
<h4>Solution</h4>
<pre class="r"><code># Problem 1
matrix(1:4, nrow = 2, ncol = 2)</code></pre>
<pre class="r"><code># Problem 2
matrix(die, nrow = 2, byrow = TRUE)</code></pre>
<pre class="r"><code># Problem 3 - multiple approaches

hand &lt;- c(&quot;king&quot;, &quot;king&quot;, &quot;king&quot;, &quot;heart&quot;, &quot;spade&quot;, &quot;club&quot;)

matrix(hand, nrow = 3)
matrix(hand, ncol = 2)
dim(hand) &lt;- c(3, 2)

# Could also start with character vector listing cards in alternating order. In this case, you will need to ask R to fill matrix by row instead of by column.

hand1 &lt;- c(&quot;king&quot;, &quot;heart&quot;, &quot;king&quot;, &quot;spade&quot;, &quot;king&quot;, &quot;club&quot;)
matrix(hand1, nrow = 3, byrow = TRUE)
matrix(hand1, ncol = 2, byrow = TRUE)</code></pre>
<pre class="r"><code># Problem 4 - cbind

cbind(suit, face)</code></pre>
<pre><code>##       suit       face   
##  [1,] &quot;hearts&quot;   &quot;ace&quot;  
##  [2,] &quot;hearts&quot;   &quot;two&quot;  
##  [3,] &quot;hearts&quot;   &quot;three&quot;
##  [4,] &quot;hearts&quot;   &quot;four&quot; 
##  [5,] &quot;hearts&quot;   &quot;five&quot; 
##  [6,] &quot;hearts&quot;   &quot;six&quot;  
##  [7,] &quot;hearts&quot;   &quot;seven&quot;
##  [8,] &quot;hearts&quot;   &quot;eight&quot;
##  [9,] &quot;hearts&quot;   &quot;nine&quot; 
## [10,] &quot;hearts&quot;   &quot;ten&quot;  
## [11,] &quot;hearts&quot;   &quot;jack&quot; 
## [12,] &quot;hearts&quot;   &quot;queen&quot;
## [13,] &quot;hearts&quot;   &quot;king&quot; 
## [14,] &quot;diamonds&quot; &quot;ace&quot;  
## [15,] &quot;diamonds&quot; &quot;two&quot;  
## [16,] &quot;diamonds&quot; &quot;three&quot;
## [17,] &quot;diamonds&quot; &quot;four&quot; 
## [18,] &quot;diamonds&quot; &quot;five&quot; 
## [19,] &quot;diamonds&quot; &quot;six&quot;  
## [20,] &quot;diamonds&quot; &quot;seven&quot;
## [21,] &quot;diamonds&quot; &quot;eight&quot;
## [22,] &quot;diamonds&quot; &quot;nine&quot; 
## [23,] &quot;diamonds&quot; &quot;ten&quot;  
## [24,] &quot;diamonds&quot; &quot;jack&quot; 
## [25,] &quot;diamonds&quot; &quot;queen&quot;
## [26,] &quot;diamonds&quot; &quot;king&quot; 
## [27,] &quot;clubs&quot;    &quot;ace&quot;  
## [28,] &quot;clubs&quot;    &quot;two&quot;  
## [29,] &quot;clubs&quot;    &quot;three&quot;
## [30,] &quot;clubs&quot;    &quot;four&quot; 
## [31,] &quot;clubs&quot;    &quot;five&quot; 
## [32,] &quot;clubs&quot;    &quot;six&quot;  
## [33,] &quot;clubs&quot;    &quot;seven&quot;
## [34,] &quot;clubs&quot;    &quot;eight&quot;
## [35,] &quot;clubs&quot;    &quot;nine&quot; 
## [36,] &quot;clubs&quot;    &quot;ten&quot;  
## [37,] &quot;clubs&quot;    &quot;jack&quot; 
## [38,] &quot;clubs&quot;    &quot;queen&quot;
## [39,] &quot;clubs&quot;    &quot;king&quot; 
## [40,] &quot;spades&quot;   &quot;ace&quot;  
## [41,] &quot;spades&quot;   &quot;two&quot;  
## [42,] &quot;spades&quot;   &quot;three&quot;
## [43,] &quot;spades&quot;   &quot;four&quot; 
## [44,] &quot;spades&quot;   &quot;five&quot; 
## [45,] &quot;spades&quot;   &quot;six&quot;  
## [46,] &quot;spades&quot;   &quot;seven&quot;
## [47,] &quot;spades&quot;   &quot;eight&quot;
## [48,] &quot;spades&quot;   &quot;nine&quot; 
## [49,] &quot;spades&quot;   &quot;ten&quot;  
## [50,] &quot;spades&quot;   &quot;jack&quot; 
## [51,] &quot;spades&quot;   &quot;queen&quot;
## [52,] &quot;spades&quot;   &quot;king&quot;</code></pre>
</div>
</div>
<div id="class" class="section level3">
<h3>Class</h3>
<p>Recall earlier we ran <code>typeof</code> and <code>class</code> on the vector <code>c(1,2,3)</code> and received different output. This arises from subtle differences in the evolution of R from S as a language during the 1980s, and is further discussed on <a href="https://stackoverflow.com/questions/8855589/a-comprehensive-survey-of-the-types-of-things-in-r-mode-and-class-and-type">stack overflow</a>. The distinction is trivial. The only thing you need to know is <code>class</code> is an attribute assigned to different objects which determine how generic R functions, such as <code>mean</code> or <code>subset</code>, operate with it. You can think of type as the <em>physical</em> representation of data whereas <em>class</em> is a <em>logical blueprint</em> giving R further information on how to represent and use the object.</p>
<p>To illustrate, note that changing the dimensions of your object will not change the type of object, but it <em>will</em> change the object’s <code>class</code> attribute:</p>
<pre class="r"><code>dim(die) &lt;- c(2, 3)
typeof(die)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<pre class="r"><code>class(die)</code></pre>
<pre><code>## [1] &quot;matrix&quot;</code></pre>
<p>A matrix is just a special case of an atomic vector. For example, every element of the <code>die</code> matrix is still a double, but now the elements have been arranged into a new 2 x 3 structure. R added a <code>class</code> attribute to <code>die</code> when you changed its dimensions which now describes <code>die</code>’s new format. Many R functions will specifically look for an object’s <code>class</code> attribute, and then handle the object in a predetermined way based on the attribute. We will briefly look at two frequently used R classes designed for specialized data: <strong>Times</strong> and <strong>Factors</strong></p>
</div>
<div id="dates-and-times" class="section level3">
<h3>Dates and Times</h3>
<p>The class attribute allows R to represent data types beyond numbers and words, often in a way that reflects a hybrid of more fundamental types. For instance, time looks like a character string when you display it, but underneath is storeid as a <code>double</code> or numeric form. It has two attached classes: <code>POSIXct</code> and <code>POSIXt</code>.</p>
<pre class="r"><code>now &lt;- Sys.time()
now</code></pre>
<pre><code>## [1] &quot;2019-07-17 22:41:05 EDT&quot;</code></pre>
<pre class="r"><code>typeof(now)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<pre class="r"><code>class(now)</code></pre>
<pre><code>## [1] &quot;POSIXct&quot; &quot;POSIXt&quot;</code></pre>
<p><code>POSIXct</code>, also known as <strong>calendar time</strong>, is the number of seconds since the beginning of 1970, in the Universal Time Coordinate (UTC) timezone (GMT as described by the French). For example, the time above occurss 1563417666 seconds after 1970-01-01 in UTC time. This means in the <code>POSIXct</code> system, R is storing this information as the actual number 1563417666. You can directly access this vector by removing the <code>class</code> attribute from <code>now</code> using the <code>unclass</code> function.</p>
<pre class="r"><code>unclass(now)</code></pre>
<pre><code>## [1] 1563417666</code></pre>
<p>So how does R change this into a date? A corresponding class is <code>POSIXlt</code>, or <strong>local time</strong> which is a list of different time attributes (e.g., days, months, years, hours, timezone). To view these components directly, we need to first <strong>convert</strong> a date-time format using <code>as.POSIXl</code> and then use <code>unclass</code> to pull out the raw information.</p>
<pre class="r"><code>unclass(as.POSIXlt(Sys.time()))</code></pre>
<pre><code>## $sec
## [1] 5.826298
## 
## $min
## [1] 41
## 
## $hour
## [1] 22
## 
## $mday
## [1] 17
## 
## $mon
## [1] 6
## 
## $year
## [1] 119
## 
## $wday
## [1] 3
## 
## $yday
## [1] 197
## 
## $isdst
## [1] 1
## 
## $zone
## [1] &quot;EDT&quot;
## 
## $gmtoff
## [1] -14400
## 
## attr(,&quot;tzone&quot;)
## [1] &quot;&quot;    &quot;EST&quot; &quot;EDT&quot;</code></pre>
<p>R integrates these two formats together with its own virtual class <code>POSIXt</code> to change seconds into a human readable date format, such as January 1, 1970, 1999/12/31, or 2019-07-11 14:16:55. This enables operations such as subtracting different date formats. For instance, you could do the following:</p>
<pre class="r"><code># Subtract two dates formatted with different symbols
as.Date(&quot;10-12-25&quot;) - as.Date(&quot;09/12/25&quot;)</code></pre>
<pre><code>## Time difference of 365 days</code></pre>
<p>You can also directly add seconds to a date and R will produce a new date. Say we wanted to know how many years in the future before a billion seconds elapses.</p>
<pre class="r"><code># Add a billion seconds to the current time 
Sys.time() + 1000000000</code></pre>
<pre><code>## [1] &quot;2051-03-26 00:27:45 EDT&quot;</code></pre>
<p>Wow. That is over 30 years from today’s date!</p>
<p>Or, you could take any number and assign it the <code>POSIXct</code> class to see how much time elapsed since Jan 1, 1970. For example, how long does it take for a million seconds to elapse?</p>
<pre class="r"><code># store 1 million as an object mil
mil &lt;- 1000000   
mil</code></pre>
<pre><code>## [1] 1e+06</code></pre>
<pre class="r"><code># Assign time classes to the number one million and print results
class(mil) &lt;- c(&quot;POSIXct&quot;, &quot;POSIXt&quot;)
mil</code></pre>
<pre><code>## [1] &quot;1970-01-12 08:46:40 EST&quot;</code></pre>
<p>January 12, 1970. Wow! A million seconds goes by much faster than a billion. This conversion works well because the <code>POSIXct</code> doesn’t require further attributes or specification. However, in general it is a bad idea to try and force the class of an object. MOre often than not this will lead to errors and incompatibility across functions.</p>
<p>There are numerous data classes in R and its packages, and new classes are invented every day. This is part of what makes R unique but also frustrating to many programmers. Classes allows for idiosyncratic differences in how data are stored and represented, leading to variability in how programs run and function. This is rarely problematic as most classes are not hard baked into R’s programming language. However, there is one exception that is so ubiquitous it should be learnt along vector types and is the chagrin to many. That class is <code>factors</code>.</p>
</div>
<div id="factors" class="section level3">
<h3>Factors</h3>
<p>Factors are R’s way of storing categorical variables, like ethnicity or type of animal, and independent variables, such as treatment and control or different experimental conditions. Factors are an important class for statistical analyses and <strong>will</strong> alter your analyses and plotting if not careful. For example, ANOVA functions often expect factors as input.</p>
<p>There are a few unique properties of factors. First, they can only take on a predefined set of discrete levels (e.g., experiment or control - nothing else). Second, factors are stored as integers (either ordered or unordered), and unique labels associated with these integers. While factors look (and often behave) like character vectors, they are actually integers under the hood. Let’s look at some examples.</p>
<p>Below is a relationship vector containing the romantic status of 4 individuals. We have abbreviated the labels.</p>
<pre class="r"><code># Relationship status of 4 people. S = single and M = Married. 

relstat &lt;- c(&quot;S&quot;, &quot;M&quot;, &quot;M&quot;, &quot;S&quot;)</code></pre>
<p>There are only <strong>two</strong> possible categories or <strong>factor levels</strong> in this data: S for Single and M for Married. The <code>factor</code> function can take vectors like this and automticallyy encode them as factors.</p>
<table>
<colgroup>
<col width="46%" />
<col width="53%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Argument</th>
<th align="left">Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>x</code></td>
<td align="left">Vector of data to convert (accepts character, numeric, logical)</td>
</tr>
<tr class="even">
<td align="left"><code>levels</code></td>
<td align="left">Vector specifying unique factor levels. Can be rearranged to set the order.</td>
</tr>
<tr class="odd">
<td align="left"><code>labels</code></td>
<td align="left">Optional character vector to assign printed labels. Must be same order as <code>levels</code>.</td>
</tr>
<tr class="even">
<td align="left"><code>ordered</code></td>
<td align="left">Logical. If TRUE, indicates levels should be treated as ordinal</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>If you enter <code>relstat</code> into <code>factor</code>, R recodes the data as integers and store the results in an integert vector. It also assigns a <code>levels</code> attribute to the integer in alphabetic order. Finally, the <code>class</code> attribute now contains <code>factor</code>.</p>
<pre class="r"><code>relstat &lt;- factor(relstat)

typeof(relstat)        #Verify the data is really integer behind the hood</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>attributes(relstat)    # Show the levels and class attribute  </code></pre>
<pre><code>## $levels
## [1] &quot;M&quot; &quot;S&quot;
## 
## $class
## [1] &quot;factor&quot;</code></pre>
<pre class="r"><code>relstat</code></pre>
<pre><code>## [1] S M M S
## Levels: M S</code></pre>
<p>R will assign <code>1</code> to the level <code>M</code> and <code>2</code> to the level <code>S</code> (because <code>M</code> comes first in the alphabet even though the first element in this vector is <code>S</code>). You can see this implicit ordering by calling the <code>levels()</code> function or see exactly how R is storing the factor with <code>unclass</code>. Underneath the hood it is more apparent how R swaps the numbers with the levels attribute when printing a factor object.</p>
<pre class="r"><code>levels(relstat)</code></pre>
<pre><code>## [1] &quot;M&quot; &quot;S&quot;</code></pre>
<pre class="r"><code>unclass(relstat)</code></pre>
<pre><code>## [1] 2 1 1 2
## attr(,&quot;levels&quot;)
## [1] &quot;M&quot; &quot;S&quot;</code></pre>
<p>Sometimes factor orders matter. Othertimes you may want a certain level to be the referent (i.e., comparison group) in an analysis. In either case, you can use the <code>levels</code> function to specify a new ordering. For instance, if we wanted single people to be the referent we could do the following.</p>
<pre class="r"><code>relstat &lt;- factor(relstat, levels = c(&quot;S&quot;, &quot;M&quot;))
relstat</code></pre>
<pre><code>## [1] S M M S
## Levels: S M</code></pre>
<p>Notice <code>S</code> appears before <code>M</code> in levels meaning we have succesfully flipped the ordering. Say we wanted R to further spell out what these factor abbreviations mean. We can do so with the <code>labels</code> function.</p>
<pre class="r"><code>factor(relstat, labels = c(&quot;Single&quot;, &quot;Married&quot;)) # Note labels will correspond to current level order</code></pre>
<pre><code>## [1] Single  Married Married Single 
## Levels: Single Married</code></pre>
<p>Be careful with labels. They must be in the <strong>same order</strong> as levels. If you flip them, R has no way of telling you the labels are wrong. In the following, we have mislabeled the data so now Single shows up as Married and vice versa.</p>
<pre class="r"><code>relstat</code></pre>
<pre><code>## [1] S M M S
## Levels: S M</code></pre>
<pre class="r"><code>factor(relstat, labels = c(&quot;Married&quot;, &quot;Single&quot;))</code></pre>
<pre><code>## [1] Married Single  Single  Married
## Levels: Married Single</code></pre>
<p>If the factor contains ordinal information (e.g., “low”, “medium” and “high”) then you may want to set <code>ordered</code> to true. R will now treat this as quasi-numerical which allows minimal calculations. Say we were doing a study on food intake and wanted to identify the condition with the lowest amount of eating.</p>
<pre class="r"><code># food factor without level information. Ordered based on alphabet

food &lt;- factor(c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;, &quot;high&quot;, &quot;low&quot;, &quot;medium&quot;))
levels(food)</code></pre>
<pre><code>## [1] &quot;high&quot;   &quot;low&quot;    &quot;medium&quot;</code></pre>
<pre class="r"><code># Switch levels but do not change ordered to true

food &lt;- factor(food, levels = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;))
levels(food)
min(food)     # as for smallest level. Will not work.</code></pre>
<pre class="r"><code># Switch levels and set ordered to true

food &lt;- factor(food, levels = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;), ordered = TRUE)
min(food)     # Works</code></pre>
<pre><code>## [1] low
## Levels: low &lt; medium &lt; high</code></pre>
<p>In the last example, these factors are represented by numbers (1, 2, 3) rather than nominal integer values.</p>
<p>Similiar to the <code>rep</code> function, you can use the <code>gl</code> function to generate factors. It takes two integers as input, an <code>n</code> indicating the number of levels and a <code>k</code> indicating the number of replications. Using our relationship status example with the new category of Divorced, we could do the following.</p>
<pre class="r"><code>gl(3, 3, labels = c(&quot;Single&quot;, &quot;Married&quot;, &quot;Divorced&quot;))</code></pre>
<pre><code>## [1] Single   Single   Single   Married  Married  Married  Divorced Divorced
## [9] Divorced
## Levels: Single Married Divorced</code></pre>
<p>A final yet <strong>important</strong> note, R has a nasty habit of converting character strings to factors when you load and create data. Programmers and researchers <strong>hate</strong> this behavior because R is making decisions without your consent. Even numeric values are sometimes converted to factors, often when a missing value is encoded with a special symbol usch as <code>.</code> or <code>-</code>. We will discuss this more in the data management section.</p>
<p>In cases where a string is inadvertently converted to a factor, use the <code>as.character</code> function to change back to pure strings.</p>
<pre class="r"><code>as.character(relstat)</code></pre>
<pre><code>## [1] &quot;S&quot; &quot;M&quot; &quot;M&quot; &quot;S&quot;</code></pre>
<div id="exercise---factor-conversion" class="section level4">
<h4>Exercise - Factor Conversion</h4>
<ol style="list-style-type: decimal">
<li><p>Convert your <code>suit</code> vector to a factor with the following level order: hearts, diamonds, spades, clubs</p></li>
<li><p>Convert your <code>face</code> vector to a factor and then unclass. What do the numbers indicate? Now, convert <code>face</code> to another factor with only the levels <code>ace</code>, <code>king</code>, and <code>queen</code>. what happens?</p></li>
</ol>
</div>
</div>
</div>
<div id="coercion-and-conversion" class="section level2">
<h2>Coercion and Conversion</h2>
<p>Many card games assign different point values to different cards. For instance, in blackjack all face cards are worth ten points. What happens if we try to make a vector by combining “king”, “heart”, and 10 together? Test it out.</p>
<pre class="r"><code>card &lt;- c(&quot;king&quot;, &quot;heart&quot;, 10)
card</code></pre>
<pre><code>## [1] &quot;king&quot;  &quot;heart&quot; &quot;10&quot;</code></pre>
<pre class="r"><code>typeof(card)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p>R has changed the number 10 into a character! If you recall, R requires all elements in a vector (including matrices) to be of the same type; if you violate this rule, R will convert elements to a single type of data. See what happens if we try to combine logicals and numbers in a matrix.</p>
<pre class="r"><code>a &lt;- rep(TRUE, 5)  # vector of 5 T values
b &lt;- 1:5           # vector of numbers

cbind(a, b)        # combine logic and numbers</code></pre>
<pre><code>##      a b
## [1,] 1 1
## [2,] 1 2
## [3,] 1 3
## [4,] 1 4
## [5,] 1 5</code></pre>
<p>The logical values are now numbers! These alterations may seem inconvenient, but they are not arbitrary. R always follows the same coercion rules. Once you are familiar with the rules, you can actually use this behavior for many useful things!</p>
<p>Whenever you attempt to combine different data types, R <strong>coerces</strong> everything in the vector to the most flexible type. Types from least to most flexible are: logical, double, and character. Hence, if there is just one “character string” in a vector, R will convert everything else in the vector to a character string. If a vector only contains logicals and numbers, R will convert all logicals to numbers: every <code>TRUE</code> becomes a 1, and every <code>FALSE</code> becomes a 0, as shown below.</p>
<center>
<img src="Figures/data_coercion.png" width="500" />
</center>
<p><br></p>
<p>This arrangement preserves information. It is easy to look at a character string and tell what information it use to contain. For example, you can easily spot the origins of “TRUE”, “True”, and “1” in a character vector. You can also easily back-transform a vector of 1s and 0s to <code>TRUE</code>s and <code>FALSE</code>s.</p>
<pre class="r"><code>sum(c(TRUE, TRUE, FALSE, TRUE))     # Under the hood, R converts the T&#39;s to 1 and the F to 0</code></pre>
<pre><code>## [1] 3</code></pre>
<p>R took the <code>sum</code> function and counted the number of <code>TRUE</code>s in the logical vector (<code>mean</code> calculate proportion). We will revisit this behavior in later sections.</p>
<p>You can instruct R to coerce a vector or other R objects to a different data types or class using the <code>as</code> function. We did this using the <code>as.POSIXlt</code> and <code>factor</code> commands to convert numbers and strings into dates and factors. Some more common conversions are changing character vectors into other types, making factors into continuous numbers, or forcing numbers into logical statements. For example, you may decide what you thought was a discrete-like variable is better represented as continuous and desire to change a factor to a number.</p>
<center>
<img src="Figures/RTypes%20and%20Conversions.png" width="500" />
</center>
<p><br></p>
<p>Here are some simple examples</p>
<pre class="r"><code>as.character(1:2)</code></pre>
<pre><code>## [1] &quot;1&quot; &quot;2&quot;</code></pre>
<pre class="r"><code>as.logical(0:1)</code></pre>
<pre><code>## [1] FALSE  TRUE</code></pre>
<pre class="r"><code>as.numeric(c(TRUE, FALSE))</code></pre>
<pre><code>## [1] 1 0</code></pre>
<pre class="r"><code>as.numeric(as.logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;blah&quot;)))  # Nest as functions to downgrade multiple data types</code></pre>
<pre><code>## [1]  1  0 NA</code></pre>
<p>Many datasets contain different kinds of data which programs like Excel and SPSS save in single data set. Don’t worry, R can do this too! To avoid issues of coercion, we use two special object types: <strong>lists</strong> and <strong>data frames</strong>.</p>
<p><strong>What the Hell</strong> you might say - if vectors and matrices can’t hold multiple types of data, why even use them? A few answers. First, because they are simpler, matrices and vectors tak up less computational space and execute operations faster. Second, these data structures are needed for certain mathematical operations on large number sets. There is a whole field of matrix algebra dedicated to just said operations! Three, sometimes you only require a single data type making vectors and matrices a better way of organizing your data.</p>
<div id="exercise---run-and-evaluate-coercion" class="section level4">
<h4>Exercise - Run and Evaluate Coercion</h4>
<ol style="list-style-type: decimal">
<li>Perform the following coercions. What happens in each case and why?</li>
</ol>
<ul>
<li>Convert <code>value</code> to a character</li>
<li>Convert <code>suit</code> to a factor</li>
<li>Convert <code>face</code> to numeric</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>What happens to the values in each of the following:</li>
</ol>
<ul>
<li><code>log_num &lt;- c(TRUE, 2, FALSE, 0, 1, TRUE)</code></li>
<li><code>char_num &lt;- c("a", 1, "b", 2, "c", 3)</code></li>
<li><code>tricky &lt;- c(1, 2, 3, "4")</code></li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>How many values in <code>combined_logical</code> object end up as “TRUE” (i.e., as a character)</li>
</ol>
<pre class="r"><code>num_logical &lt;- c(1, 2, 3, TRUE) 
char_logical &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, TRUE) 
combined_logical &lt;- c(num_logical, char_logical) </code></pre>
</div>
</div>
<div id="lists" class="section level2">
<h2>Lists</h2>
<center>
<img src="Figures/lists.png" width="150" />
</center>
<p><br></p>
<p>Lists are like atomic vectors because they group data into a one-dimensional set. However, lists do not group together individual values; lists group together R objects of different types and lengths. For example, we could include a numeric vector length 50 in the first element, character vector length 1 in the second element, and a new list of length 2 in its third element. To do so, use the <code>list</code> function which operators like the <code>c</code> function for vectors.</p>
<pre class="r"><code>list &lt;- list(1:50, &quot;Hi&quot;, list(TRUE, FALSE))
list  </code></pre>
<pre><code>## [[1]]
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
## [24] 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
## [47] 47 48 49 50
## 
## [[2]]
## [1] &quot;Hi&quot;
## 
## [[3]]
## [[3]][[1]]
## [1] TRUE
## 
## [[3]][[2]]
## [1] FALSE</code></pre>
<p>The initial double-bracketed indices (e.g., <code>[[1]]</code>) tell you which element of the list is being displayed. For instance, <code>[[1]]</code> refers to the <code>1:50</code> numerical vector, <code>[[2]]</code> refers to the <code>"Hi"</code> character vector, and <code>[[3]]</code> refers the sub-list. The single-bracket (e.g., <code>[1]</code>) indices tell you which sub-element of a list element is being displayed. For example, <code>30</code> is the 30th sub-element of the first element in the list. <code>Hi</code> is the first sub-element of the list’s second element. This two-system notation arises because each eleemnt of a list can be <em>any</em> R object, including a new vector (or list) with its own indices. For instance, <code>TRUE</code> is embedded in its own list within a list, hence the <code>[[3]][[1]]</code> notation stating the first element of the 2nd list which is itself the 3rd element of the 1st list. Bonkers right!</p>
<p>The above example is a little archaic and doesn’t illustrate the real power of lists. Many R functions store output in lists because they are a highly flexible storage containers. These lists often <em>name</em> the components, such as <strong>coefficients</strong>, <strong>standard errors</strong>, <strong>tvalue</strong>, and <strong>warning messages</strong> to store output of various analyses, such as a linear regression. This allows researchers to pull just the information they need, whether it be a single <em>p</em>-value or an entire set of beta weights.</p>
<p>For example, say your a super huge HBO fan and decided to store information all about the popular show Game of Thrones.</p>
<center>
<img src="Figures/GOT_Betrayals.jpg" width="400" />
</center>
<p><br></p>
<p>In this <code>list</code>, you might provide the show’s title, number of seasons, name of your favorite characters, and small set of numeric reviews out of 10. You can assign names to each component by typing the label followed by an <code>=</code> sign and then an input vector. This allows several vectors of different length and type to accomodate different forms of information. Here is an example.</p>
<pre class="r"><code>GOT &lt;- list(showname = &quot;Game of Thrones&quot;,
            seasons = 8,
            characters = c(&quot;Tyrion Lannister&quot;, &quot;Jaime Lannister&quot;, &quot;Bran Stark&quot;, &quot;Arya Stark&quot;,
                           &quot;Jon Snow&quot;, &quot;Daenerys Targaryen&quot;),
            reviews = c(9, 10, 9, 10, 10, 8)
            )
GOT</code></pre>
<pre><code>## $showname
## [1] &quot;Game of Thrones&quot;
## 
## $seasons
## [1] 8
## 
## $characters
## [1] &quot;Tyrion Lannister&quot;   &quot;Jaime Lannister&quot;    &quot;Bran Stark&quot;        
## [4] &quot;Arya Stark&quot;         &quot;Jon Snow&quot;           &quot;Daenerys Targaryen&quot;
## 
## $reviews
## [1]  9 10  9 10 10  8</code></pre>
<p>As you can imagine, the structure of lists can become quite complicated, but this flexibility makes lists a useful all-purpose storage tool in R: you can group together anything with a list. Let’s practice.</p>
<div id="exercise---make-a-list" class="section level4">
<h4>Exercise - Make a List</h4>
<ol style="list-style-type: decimal">
<li>Use a <strong>named</strong> list to store a single playing card, like the ten of clubs, which has a point value of 10. The list should save the face of the card, the suit, and point value as seperate labeled elements.</li>
</ol>
</div>
<div id="solution-2" class="section level4">
<h4>Solution</h4>
<pre class="r"><code>card &lt;- list(face = &quot;ten&quot;,
             suit = &quot;clubs&quot;,
             value = &quot;10&quot;)
card</code></pre>
<pre><code>## $face
## [1] &quot;ten&quot;
## 
## $suit
## [1] &quot;clubs&quot;
## 
## $value
## [1] &quot;10&quot;</code></pre>
<p>We can also use a list to store a whole deck of cards. You could save each card as its own list in a list (52 sublists) or have three elements each with all suits, values, and faces (three 52 element vectors). However, there is a much cleaner way to represent this information using a special type of list, known as a <strong>data frame</strong>.</p>
</div>
</div>
<div id="data-frames" class="section level2">
<h2>Data Frames</h2>
<table>
<colgroup>
<col width="30%" />
<col width="34%" />
<col width="34%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Description</th>
<th align="left">Example</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>data.frame()</code></td>
<td align="left">Create a dataframe from named columns</td>
<td align="left"><code>data.frame(age = c(19, 21), sex = c("m", "f")</code></td>
</tr>
<tr class="even">
<td align="left"><code>str(x), summary(x)</code></td>
<td align="left">Show structure (i.e., dimensions and classes) and summary statistics</td>
<td align="left"><code>str(mtcars), summary(mtcars)</code></td>
</tr>
<tr class="odd">
<td align="left"><code>head(x), tail(x)</code></td>
<td align="left">Print the first few rows (or last few rows).</td>
<td align="left"><code>head(mtcars), tail(mtcars)</code></td>
</tr>
<tr class="even">
<td align="left"><code>nrow(x), ncol(x), dim(x)</code></td>
<td align="left">Count the number of rows and columns</td>
<td align="left"><code>nrow(mtcars), ncol(mtcars), dim(mtcars)</code></td>
</tr>
<tr class="odd">
<td align="left"><code>rownames(), colnames(), names()</code></td>
<td align="left">Show the row (or column) names</td>
<td align="left"><code>rownames(mtcars), names(mtcars)</code></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>A data frame is the most common way of storing data in R, and if used systematically makes data analysis easier. Under the hood, a data frame is a list of equal-length vectors. This makes it a 2-dimensional structure, so it shares properties of both the matrix and the list. It is R’s equivalent to an Excel spreadsheet because it stores data in a similiar format.</p>
<p>Data frames group vectors together into a table where each vector becomes a column. Each column can contain different data types but all cells within a column must be the same type of data.</p>
<center>
<img src="Figures/df.png" width="150" />
</center>
<p><br> To create a dataframe from vectors, use the<code>data.frame</code> function. The <code>data.frame()</code> function works very similarly to <code>cbind()</code> - the only differences is that in <code>data.frame()</code> you specify names for each of the columns as you define them. Remeber to separate each vector by a comma. Let’s create a simple dataframe called <code>survey</code> using the <code>data.frame</code> function with a mixture of text and numeric columns.</p>
<pre class="r"><code># Create a dataframe of survey data

survey &lt;- data.frame(&quot;index&quot; = c(1, 2, 3, 4, 5),
                     &quot;sex&quot; = c(&quot;m&quot;, &quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;),
                     &quot;age&quot; = c(99, 46, 23, 54, 23))

survey</code></pre>
<pre><code>##   index sex age
## 1     1   m  99
## 2     2   m  46
## 3     3   m  23
## 4     4   f  54
## 5     5   f  23</code></pre>
<p>In the previous code, I named the columns in <code>survey</code> <code>index</code>, <code>sex</code>, and <code>age</code>, but you can name them whatever you want. If you look at the <code>typeof</code> function for a data frame, you will see it is actually a list. In fact, each data frame is a list with class <code>data.frame</code> which makes it behave like a matrix.</p>
<pre class="r"><code>typeof(survey)</code></pre>
<pre><code>## [1] &quot;list&quot;</code></pre>
<pre class="r"><code>class(survey)</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<p>Two useful functions for getting an overall sense of your data are <code>str</code> and <code>summary</code>. <code>str</code> provides the dimensions, types of objects grouped together, and other summary information for a data.frame (or list). <code>summary</code> provides some descriptive statistics. Let’s look at each in turn.</p>
<pre class="r"><code>str(survey)</code></pre>
<pre><code>## &#39;data.frame&#39;:    5 obs. of  3 variables:
##  $ index: num  1 2 3 4 5
##  $ sex  : Factor w/ 2 levels &quot;f&quot;,&quot;m&quot;: 2 2 2 1 1
##  $ age  : num  99 46 23 54 23</code></pre>
<p>You can see there are 5 participants with 3 variables, each of which is listed along with its data type. R will display the first several values for each variable. Second, it converted the string column <code>sex</code> to a factor, assuming there were only 2 levels, <code>f</code> and <code>m</code>. Let’s run <code>summary</code> on <code>survey</code>.</p>
<pre class="r"><code>summary(survey)</code></pre>
<pre><code>##      index   sex        age    
##  Min.   :1   f:2   Min.   :23  
##  1st Qu.:2   m:3   1st Qu.:23  
##  Median :3         Median :46  
##  Mean   :3         Mean   :49  
##  3rd Qu.:4         3rd Qu.:54  
##  Max.   :5         Max.   :99</code></pre>
<p>R has given us frequencies for the <code>sex</code> factor and descriptive information such as a sense of the range, quartiles, and central tendencies for numerical columns of <code>index</code> and <code>age</code>. This can be helpful for finding outliers, data entry errors, or getting a sense of your data’s distributions.</p>
<p>One key argument to <code>data.frame()</code> and similiar functions is <code>stringsAsFactors</code>. As noted above, R went ahead and changed your string variables to factors without your permission. Sometimes this is what you want. More often than not this leads to weirdness and frustration. Take the following example where there was a slight alteration in how the <code>sex</code> data were entered.</p>
<pre class="r"><code>survey2 &lt;- data.frame(index = 1:5,
                      sex = c(&quot;m&quot;, &quot;M&quot;, &quot;m&quot;, &quot;F&quot;, &quot;f&quot;),   # notice upper and lower cases
                      age = c(99, 46, 23, 54, 23))
str(survey2)</code></pre>
<pre><code>## &#39;data.frame&#39;:    5 obs. of  3 variables:
##  $ index: int  1 2 3 4 5
##  $ sex  : Factor w/ 4 levels &quot;f&quot;,&quot;F&quot;,&quot;m&quot;,&quot;M&quot;: 3 4 3 2 1
##  $ age  : num  99 46 23 54 23</code></pre>
<p>Notice R now thinks sex has <strong>four levels</strong> instead of <strong>two</strong>. This can lead to all kinds of silliness in analyses and plots. Things become even messier when R tries to make data like addresses, phone numbers, or other raw textual data into very large factors. To prevent this from happening, set the argument <code>stringsAsFactors = FALSE</code> within <code>data.frame</code>.</p>
<pre class="r"><code>survey2 &lt;- data.frame(index = 1:5,
                      sex = c(&quot;m&quot;, &quot;M&quot;, &quot;m&quot;, &quot;F&quot;, &quot;f&quot;),  
                      age = c(99, 46, 23, 54, 23),
                      stringsAsFactors = F)               # Add this argument
str(survey2)</code></pre>
<pre><code>## &#39;data.frame&#39;:    5 obs. of  3 variables:
##  $ index: int  1 2 3 4 5
##  $ sex  : chr  &quot;m&quot; &quot;M&quot; &quot;m&quot; &quot;F&quot; ...
##  $ age  : num  99 46 23 54 23</code></pre>
<p>Looking at the new version we can see no factors were retained. There are several other useful helper functions to navigate dataframes. To quickly get a glimpse of the first or last rows of a dataframe, use <code>head</code> and <code>tail</code>. We can quickly glimpse the built-in R dataset <code>ChickenWeight</code> to get a sense of the information inside.</p>
<pre class="r"><code># Show first few rows
head(ChickWeight)</code></pre>
<pre><code>## Grouped Data: weight ~ Time | Chick
##   weight Time Chick Diet
## 1     42    0     1    1
## 2     51    2     1    1
## 3     59    4     1    1
## 4     64    6     1    1
## 5     76    8     1    1
## 6     93   10     1    1</code></pre>
<pre class="r"><code># Show last few rows
tail(ChickWeight)</code></pre>
<pre><code>## Grouped Data: weight ~ Time | Chick
##     weight Time Chick Diet
## 573    155   12    50    4
## 574    175   14    50    4
## 575    205   16    50    4
## 576    234   18    50    4
## 577    264   20    50    4
## 578    264   21    50    4</code></pre>
<p>We can run <code>View()</code> to see a new window like the one below showing the data.</p>
<pre class="r"><code>View(ChickWeight)</code></pre>
<center>
<img src="Figures/Chick_weight.png" width="300" />
</center>
<p><br></p>
<p>Finally, all name and dimensional attributes can be accessed using the same functions as before, <code>names</code> and <code>dim</code>. There are also the more specialized <code>nrow</code> or <code>ncol</code> as well as <code>rownames</code> or <code>colnames</code> options for accessing just one side.</p>
<pre class="r"><code>nrow(ChickWeight)</code></pre>
<pre><code>## [1] 578</code></pre>
<pre class="r"><code>dim(ChickWeight)</code></pre>
<pre><code>## [1] 578   4</code></pre>
<pre class="r"><code>names(ChickWeight)</code></pre>
<pre><code>## [1] &quot;weight&quot; &quot;Time&quot;   &quot;Chick&quot;  &quot;Diet&quot;</code></pre>
<pre class="r"><code>colnames(ChickWeight)</code></pre>
<pre><code>## [1] &quot;weight&quot; &quot;Time&quot;   &quot;Chick&quot;  &quot;Diet&quot;</code></pre>
<p>We will explore how to slice, modify, and run calculations on data frames and vectors. R Studio provides a helpful set of cheat sheets on a variety of topics, including how to work with basic R objects. Here is a snippet of some basic notations, along with illustrations of subsetting which we will cover shortly.</p>
<center>
<img src="Figures/data_frame.png" width="300" />
</center>
<p><br></p>
<div id="available-dataframes-in-r" class="section level3">
<h3>Available Dataframes in R</h3>
<p>Now you know ho to use functions like <code>cbind()</code> and <code>data.frame()</code> to make your own data frames. However, for demonstration purposes, it’s frequently easier to use existing data frames rather than always creating your own. Thankfully, R has use covered: R has several datasets that come pre-installed in a package called <code>datasets</code> – you don’t need to install this package, it’s included with base R. In addition, there are some useful datasets in the <code>tidyverse</code> package which we will use to illustrate certain data wrangling principles. These data sets allow all R users to test and compare code on the same information and see if they can replicate other examples. To see a complete list of all the datasets included in the datasets package, run the code: <code>library(help = "datasets")</code>. The table below shows a few datasets that we will be using in future examples.</p>
<table>
<colgroup>
<col width="22%" />
<col width="56%" />
<col width="9%" />
<col width="11%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Dataset</th>
<th align="left">Description</th>
<th align="left">Rows</th>
<th align="left">Columns</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>ChickWeight</code></td>
<td align="left">Experiment on the effect of diet on early growth of chicks.</td>
<td align="left">578</td>
<td align="left">4</td>
</tr>
<tr class="even">
<td align="left"><code>Cars93</code> (load <code>MASS</code>)</td>
<td align="left">Features of different cars from 1993.</td>
<td align="left">93</td>
<td align="left">27</td>
</tr>
<tr class="odd">
<td align="left"><code>msleep</code> (load <code>tidyverse</code>)</td>
<td align="left">Sleep habits for a variety of mammals and insects.</td>
<td align="left">83</td>
<td align="left">11</td>
</tr>
<tr class="even">
<td align="left"><code>PlantGrowth</code></td>
<td align="left">Results from an experiment to compare yields (as measured by dried weight of plants) obtained under a control and two different treatment conditions.</td>
<td align="left">30</td>
<td align="left">2</td>
</tr>
</tbody>
</table>
<div id="exercises---building-and-exploring-dataframes" class="section level4">
<h4>Exercises - Building and Exploring Dataframes</h4>
<ol style="list-style-type: decimal">
<li><p>A data frame is a great way to build an entire deck of cards. You can make each row a playing card and each column a type of value - each with its own appropriate data type. Using the <code>data.frame</code> function, combine your <code>face</code>, <code>suit</code>, and <code>value</code> vectors into a data.frame called <code>deck</code>.</p></li>
<li><p>Use <code>str</code> on the <code>Cars93</code> data frame (available from <code>MASS</code> package). What are the dimensions and data types? Can you deduce what some of the variables tell us about different cars?</p></li>
<li><p>Use the <code>summary</code> on the <code>ChickWeight</code> data frame. What is the average weight of a baby Chick (reported in grams)? Further, can you figure out how many <code>diet</code> conditions exist and how many days the chickens were measured?</p></li>
</ol>
</div>
<div id="solutions" class="section level4">
<h4>Solutions</h4>
<pre class="r"><code># Solution 1
deck &lt;- data.frame(face = face,
                   suit = suit,
                   value = value)</code></pre>
<pre class="r"><code># Solution 2
str(MASS::Cars93)</code></pre>
<pre><code>## &#39;data.frame&#39;:    93 obs. of  27 variables:
##  $ Manufacturer      : Factor w/ 32 levels &quot;Acura&quot;,&quot;Audi&quot;,..: 1 1 2 2 3 4 4 4 4 5 ...
##  $ Model             : Factor w/ 93 levels &quot;100&quot;,&quot;190E&quot;,&quot;240&quot;,..: 49 56 9 1 6 24 54 74 73 35 ...
##  $ Type              : Factor w/ 6 levels &quot;Compact&quot;,&quot;Large&quot;,..: 4 3 1 3 3 3 2 2 3 2 ...
##  $ Min.Price         : num  12.9 29.2 25.9 30.8 23.7 14.2 19.9 22.6 26.3 33 ...
##  $ Price             : num  15.9 33.9 29.1 37.7 30 15.7 20.8 23.7 26.3 34.7 ...
##  $ Max.Price         : num  18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3 ...
##  $ MPG.city          : int  25 18 20 19 22 22 19 16 19 16 ...
##  $ MPG.highway       : int  31 25 26 26 30 31 28 25 27 25 ...
##  $ AirBags           : Factor w/ 3 levels &quot;Driver &amp; Passenger&quot;,..: 3 1 2 1 2 2 2 2 2 2 ...
##  $ DriveTrain        : Factor w/ 3 levels &quot;4WD&quot;,&quot;Front&quot;,..: 2 2 2 2 3 2 2 3 2 2 ...
##  $ Cylinders         : Factor w/ 6 levels &quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,..: 2 4 4 4 2 2 4 4 4 5 ...
##  $ EngineSize        : num  1.8 3.2 2.8 2.8 3.5 2.2 3.8 5.7 3.8 4.9 ...
##  $ Horsepower        : int  140 200 172 172 208 110 170 180 170 200 ...
##  $ RPM               : int  6300 5500 5500 5500 5700 5200 4800 4000 4800 4100 ...
##  $ Rev.per.mile      : int  2890 2335 2280 2535 2545 2565 1570 1320 1690 1510 ...
##  $ Man.trans.avail   : Factor w/ 2 levels &quot;No&quot;,&quot;Yes&quot;: 2 2 2 2 2 1 1 1 1 1 ...
##  $ Fuel.tank.capacity: num  13.2 18 16.9 21.1 21.1 16.4 18 23 18.8 18 ...
##  $ Passengers        : int  5 5 5 6 4 6 6 6 5 6 ...
##  $ Length            : int  177 195 180 193 186 189 200 216 198 206 ...
##  $ Wheelbase         : int  102 115 102 106 109 105 111 116 108 114 ...
##  $ Width             : int  68 71 67 70 69 69 74 78 73 73 ...
##  $ Turn.circle       : int  37 38 37 37 39 41 42 45 41 43 ...
##  $ Rear.seat.room    : num  26.5 30 28 31 27 28 30.5 30.5 26.5 35 ...
##  $ Luggage.room      : int  11 15 14 17 13 16 17 21 14 18 ...
##  $ Weight            : int  2705 3560 3375 3405 3640 2880 3470 4105 3495 3620 ...
##  $ Origin            : Factor w/ 2 levels &quot;USA&quot;,&quot;non-USA&quot;: 2 2 2 2 2 1 1 1 1 1 ...
##  $ Make              : Factor w/ 93 levels &quot;Acura Integra&quot;,..: 1 2 4 3 5 6 7 9 8 10 ...</code></pre>
<pre class="r"><code># Solution 3
summary(ChickWeight)</code></pre>
<pre><code>##      weight           Time           Chick     Diet   
##  Min.   : 35.0   Min.   : 0.00   13     : 12   1:220  
##  1st Qu.: 63.0   1st Qu.: 4.00   9      : 12   2:120  
##  Median :103.0   Median :10.00   20     : 12   3:120  
##  Mean   :121.8   Mean   :10.72   10     : 12   4:118  
##  3rd Qu.:163.8   3rd Qu.:16.00   17     : 12          
##  Max.   :373.0   Max.   :21.00   19     : 12          
##                                  (Other):506</code></pre>
</div>
</div>
</div>
<div id="summary" class="section level2">
<h2>Summary</h2>
<p>You can work with R data using five different objects, each of which lets you store different types of values in different relationships. The vector is the most fundamental R unit from which everything evolves. Vectors have the basic properties of <code>length</code> and data type (<code>typeof</code>). Lists are a more generic vector allowing objects of different types and lengths. More sophisticated objects inherit <strong>attributes</strong> or metadata which can modify their functionality. A matrix, for instance, is a vector with a 2-dimensional property whereas a data frame is a list that acts like a matrix. Of these objects, data frames are by far the most useful for social science. Data frames store the most common forms of data accessed by others programs such as excel or SPSS, tabular data. All packages operate through these fundamental objects, hence understanding their structure allows you to exploit R’s full potential.</p>
<center>
<img src="Figures/R_AllObjectTypes.png" width="500" />
</center>
<p><br></p>
</div>
<div id="r-notation" class="section level1">
<h1>R Notation</h1>
<p>By now you are a whiz at data structures and the R interface. You can access all the contents of <code>Cars93</code>, your <code>deck</code> of cards, and other data frames. However, you will often want to access specific <strong>subsets</strong> of your data based on some criteria. For instance, we may want to randomly sample just <strong>one</strong> card (i.e., row) from your <code>deck</code>, much like we are dealing. Or, for the <code>Cars93</code> data set, perhaps you want to look at just the last 10 vehicles, choose only the priciest vehicles (e.g., &gt; 100k), or select only vans.</p>
<p>This section will help you master subsetting by starting with the simplest type: subsetting an object with <code>[</code>. We will gradually expand into more complex operations. Subsetting is a natural complement to <code>str()</code>. <code>str()</code> shows you the structure of any object, and subsetting allows you to pull out the pieces you are interested.</p>
<p>To begin in pulling things out, you will need to access specific values of an R object using <strong>indexing</strong> with brackets <code>[ , ]</code>. To extract a value or set of values from a data frame, for example, you write the data frame’s name followed by a pair of hard brackets:</p>
<pre class="r"><code>deck[ , ]</code></pre>
<p>Between the brackets will go two indexes separated by a comma. The indexes tell R which values to return. R will use the first index to subset the rows of the data frame and the second index to subset the columns. You can think of the notation as <code>data[rows, columns]</code>.</p>
<p>You will have a choice as to what you put into <code>rows</code> and <code>columns</code> in writing indexes. For simplicity, we discuss 4 different possibilities which can be used in combination. They are all simple yet handy in different circumstances. You can create indices with:</p>
<ul>
<li>Integers (positive and negative)</li>
<li>Blank spaces</li>
<li>Names</li>
<li>Logical Values</li>
</ul>
<div id="integers" class="section level3">
<h3>Integers</h3>
<p>R treats integers just like <em>ij</em> notiation in linear algebra: <code>deck[i, j]</code> will return the <em>ith</em> row in the <em>jth</em> column. For example</p>
<pre class="r"><code>head(deck)</code></pre>
<pre><code>##    face   suit value
## 1   ace hearts     1
## 2   two hearts     2
## 3 three hearts     3
## 4  four hearts     4
## 5  five hearts     5
## 6   six hearts     6</code></pre>
<pre class="r"><code># Return element from row 1, column 1
deck[1, 1]</code></pre>
<pre><code>## [1] ace
## 13 Levels: ace eight five four jack king nine queen seven six ... two</code></pre>
<pre class="r"><code># Return element from row 4, column 3 
deck[4 ,3]</code></pre>
<pre><code>## [1] 4</code></pre>
<p>To extract more than one value, use a vector of positive integers. For example, you can return the first row of <code>deck</code> with <code>deck[1, c(1,2,3)]</code> or <code>deck[1, 1:3]</code>.</p>
<pre class="r"><code># Row 1, all columns
deck[1, 1:3]</code></pre>
<pre><code>##   face   suit value
## 1  ace hearts     1</code></pre>
<p>R returns the values of <code>deck</code> that are in both the first row and first, second, and third columns. You can even access the same set of elements multiple times using repetition.</p>
<pre class="r"><code># Repeat the first row and first three columns three times
deck[c(1, 1, 1), 1:3]</code></pre>
<pre><code>##     face   suit value
## 1    ace hearts     1
## 1.1  ace hearts     1
## 1.2  ace hearts     1</code></pre>
<p>Note R won’t actually <strong>remove</strong> these values from the <code>deck</code>; rather, R gives you a new set of values copied from the originals. You can then save these values into a new R object with the assignment operator.</p>
<pre class="r"><code>new &lt;- deck[1, 1:3]
new</code></pre>
<pre><code>##   face   suit value
## 1  ace hearts     1</code></pre>
<center>
<img src="Figures/R_indexing.png" width="500" />
</center>
<p><br></p>
<p>R’s notation system is not limited to data frames. You can use the same syntax to select values in any R object, as long as you supply one index for each object dimension. For example, you can subset a one-dimensional vector using a single index.</p>
<pre class="r"><code>dog_breeds &lt;- c(&quot;Labrador&quot;, &quot;Golden Retriever&quot;, &quot;Poodle&quot;, &quot;Bulldog&quot;, &quot;Beagle&quot;, &quot;German Shepherd&quot;, &quot;Rottweiler&quot;)

# What is the first dog breed?
dog_breeds[1]</code></pre>
<pre><code>## [1] &quot;Labrador&quot;</code></pre>
<pre class="r"><code># What are the first five dog breeds?
dog_breeds[1:5]</code></pre>
<pre><code>## [1] &quot;Labrador&quot;         &quot;Golden Retriever&quot; &quot;Poodle&quot;          
## [4] &quot;Bulldog&quot;          &quot;Beagle&quot;</code></pre>
<pre class="r"><code># What is every second dog breed?
dog_breeds[seq(1,length(dog_breeds),2)]    # Use length to set max value for a vector</code></pre>
<pre><code>## [1] &quot;Labrador&quot;   &quot;Poodle&quot;     &quot;Beagle&quot;     &quot;Rottweiler&quot;</code></pre>
<p>Finally, negative integers do the exact <em>opposite</em> of positive integers: R returns every element <em>except</em> the elements in a negative index. For example, <code>deck[-1, 1:3]</code> returns everything <em>but</em> the first row of <code>deck</code>. `deck[-(2:52), 1:3)] <em>only</em> returns the first row and discards everything else. Negative integers are often a more efficient way to subset if you want to include a majority of a data frame’s rows and columns.</p>
<pre class="r"><code># Eliminate just the first row
deck[-1, 1:3]</code></pre>
<pre><code>##     face     suit value
## 2    two   hearts     2
## 3  three   hearts     3
## 4   four   hearts     4
## 5   five   hearts     5
## 6    six   hearts     6
## 7  seven   hearts     7
## 8  eight   hearts     8
## 9   nine   hearts     9
## 10   ten   hearts    10
## 11  jack   hearts    11
## 12 queen   hearts    12
## 13  king   hearts    13
## 14   ace diamonds     1
## 15   two diamonds     2
## 16 three diamonds     3
## 17  four diamonds     4
## 18  five diamonds     5
## 19   six diamonds     6
## 20 seven diamonds     7
## 21 eight diamonds     8
## 22  nine diamonds     9
## 23   ten diamonds    10
## 24  jack diamonds    11
## 25 queen diamonds    12
## 26  king diamonds    13
## 27   ace    clubs     1
## 28   two    clubs     2
## 29 three    clubs     3
## 30  four    clubs     4
## 31  five    clubs     5
## 32   six    clubs     6
## 33 seven    clubs     7
## 34 eight    clubs     8
## 35  nine    clubs     9
## 36   ten    clubs    10
## 37  jack    clubs    11
## 38 queen    clubs    12
## 39  king    clubs    13
## 40   ace   spades     1
## 41   two   spades     2
## 42 three   spades     3
## 43  four   spades     4
## 44  five   spades     5
## 45   six   spades     6
## 46 seven   spades     7
## 47 eight   spades     8
## 48  nine   spades     9
## 49   ten   spades    10
## 50  jack   spades    11
## 51 queen   spades    12
## 52  king   spades    13</code></pre>
<pre class="r"><code># Eliminate everything but first and last row
deck[-2:-51, 1:3]</code></pre>
<pre><code>##    face   suit value
## 1   ace hearts     1
## 52 king spades    13</code></pre>
<pre class="r"><code># Eliminate last column for first row
deck[1, -3]</code></pre>
<pre><code>##   face   suit
## 1  ace hearts</code></pre>
</div>
<div id="blank" class="section level3">
<h3>Blank</h3>
<p>If you want to look at an <strong>entire</strong> row or column of a matrix or dataframe, you can leave the corresponding index blank. For example, to see the entire 1st row of the <code>ChickWeight</code> dataframe we can set the row index to 1 and leave the column index blank.</p>
<pre class="r"><code># Give me the 1st row (and all columns) or ChickWeight
ChickWeight[1, ]</code></pre>
<pre><code>## Grouped Data: weight ~ Time | Chick
##   weight Time Chick Diet
## 1     42    0     1    1</code></pre>
<p>This particular Chicken weighed 42 grams at birth and is in the 1st diet condition. Similarly, if you wanted to get the entire 3 and 4th column (and all rows), set the column index to <code>3:4</code> or <code>c(3,4)</code> and leave the row index blank.</p>
<pre class="r"><code>ChickWeight[ ,3:4]</code></pre>
<pre><code>##     Chick Diet
## 1       1    1
## 2       1    1
## 3       1    1
## 4       1    1
## 5       1    1
## 6       1    1
## 7       1    1
## 8       1    1
## 9       1    1
## 10      1    1
## 11      1    1
## 12      1    1
## 13      2    1
## 14      2    1
## 15      2    1
## 16      2    1
## 17      2    1
## 18      2    1
## 19      2    1
## 20      2    1
## 21      2    1
## 22      2    1
## 23      2    1
## 24      2    1
## 25      3    1
## 26      3    1
## 27      3    1
## 28      3    1
## 29      3    1
## 30      3    1
## 31      3    1
## 32      3    1
## 33      3    1
## 34      3    1
## 35      3    1
## 36      3    1
## 37      4    1
## 38      4    1
## 39      4    1
## 40      4    1
## 41      4    1
## 42      4    1
## 43      4    1
## 44      4    1
## 45      4    1
## 46      4    1
## 47      4    1
## 48      4    1
## 49      5    1
## 50      5    1
## 51      5    1
## 52      5    1
## 53      5    1
## 54      5    1
## 55      5    1
## 56      5    1
## 57      5    1
## 58      5    1
## 59      5    1
## 60      5    1
## 61      6    1
## 62      6    1
## 63      6    1
## 64      6    1
## 65      6    1
## 66      6    1
## 67      6    1
## 68      6    1
## 69      6    1
## 70      6    1
## 71      6    1
## 72      6    1
## 73      7    1
## 74      7    1
## 75      7    1
## 76      7    1
## 77      7    1
## 78      7    1
## 79      7    1
## 80      7    1
## 81      7    1
## 82      7    1
## 83      7    1
## 84      7    1
## 85      8    1
## 86      8    1
## 87      8    1
## 88      8    1
## 89      8    1
## 90      8    1
## 91      8    1
## 92      8    1
## 93      8    1
## 94      8    1
## 95      8    1
## 96      9    1
## 97      9    1
## 98      9    1
## 99      9    1
## 100     9    1
## 101     9    1
## 102     9    1
## 103     9    1
## 104     9    1
## 105     9    1
## 106     9    1
## 107     9    1
## 108    10    1
## 109    10    1
## 110    10    1
## 111    10    1
## 112    10    1
## 113    10    1
## 114    10    1
## 115    10    1
## 116    10    1
## 117    10    1
## 118    10    1
## 119    10    1
## 120    11    1
## 121    11    1
## 122    11    1
## 123    11    1
## 124    11    1
## 125    11    1
## 126    11    1
## 127    11    1
## 128    11    1
## 129    11    1
## 130    11    1
## 131    11    1
## 132    12    1
## 133    12    1
## 134    12    1
## 135    12    1
## 136    12    1
## 137    12    1
## 138    12    1
## 139    12    1
## 140    12    1
## 141    12    1
## 142    12    1
## 143    12    1
## 144    13    1
## 145    13    1
## 146    13    1
## 147    13    1
## 148    13    1
## 149    13    1
## 150    13    1
## 151    13    1
## 152    13    1
## 153    13    1
## 154    13    1
## 155    13    1
## 156    14    1
## 157    14    1
## 158    14    1
## 159    14    1
## 160    14    1
## 161    14    1
## 162    14    1
## 163    14    1
## 164    14    1
## 165    14    1
## 166    14    1
## 167    14    1
## 168    15    1
## 169    15    1
## 170    15    1
## 171    15    1
## 172    15    1
## 173    15    1
## 174    15    1
## 175    15    1
## 176    16    1
## 177    16    1
## 178    16    1
## 179    16    1
## 180    16    1
## 181    16    1
## 182    16    1
## 183    17    1
## 184    17    1
## 185    17    1
## 186    17    1
## 187    17    1
## 188    17    1
## 189    17    1
## 190    17    1
## 191    17    1
## 192    17    1
## 193    17    1
## 194    17    1
## 195    18    1
## 196    18    1
## 197    19    1
## 198    19    1
## 199    19    1
## 200    19    1
## 201    19    1
## 202    19    1
## 203    19    1
## 204    19    1
## 205    19    1
## 206    19    1
## 207    19    1
## 208    19    1
## 209    20    1
## 210    20    1
## 211    20    1
## 212    20    1
## 213    20    1
## 214    20    1
## 215    20    1
## 216    20    1
## 217    20    1
## 218    20    1
## 219    20    1
## 220    20    1
## 221    21    2
## 222    21    2
## 223    21    2
## 224    21    2
## 225    21    2
## 226    21    2
## 227    21    2
## 228    21    2
## 229    21    2
## 230    21    2
## 231    21    2
## 232    21    2
## 233    22    2
## 234    22    2
## 235    22    2
## 236    22    2
## 237    22    2
## 238    22    2
## 239    22    2
## 240    22    2
## 241    22    2
## 242    22    2
## 243    22    2
## 244    22    2
## 245    23    2
## 246    23    2
## 247    23    2
## 248    23    2
## 249    23    2
## 250    23    2
## 251    23    2
## 252    23    2
## 253    23    2
## 254    23    2
## 255    23    2
## 256    23    2
## 257    24    2
## 258    24    2
## 259    24    2
## 260    24    2
## 261    24    2
## 262    24    2
## 263    24    2
## 264    24    2
## 265    24    2
## 266    24    2
## 267    24    2
## 268    24    2
## 269    25    2
## 270    25    2
## 271    25    2
## 272    25    2
## 273    25    2
## 274    25    2
## 275    25    2
## 276    25    2
## 277    25    2
## 278    25    2
## 279    25    2
## 280    25    2
## 281    26    2
## 282    26    2
## 283    26    2
## 284    26    2
## 285    26    2
## 286    26    2
## 287    26    2
## 288    26    2
## 289    26    2
## 290    26    2
## 291    26    2
## 292    26    2
## 293    27    2
## 294    27    2
## 295    27    2
## 296    27    2
## 297    27    2
## 298    27    2
## 299    27    2
## 300    27    2
## 301    27    2
## 302    27    2
## 303    27    2
## 304    27    2
## 305    28    2
## 306    28    2
## 307    28    2
## 308    28    2
## 309    28    2
## 310    28    2
## 311    28    2
## 312    28    2
## 313    28    2
## 314    28    2
## 315    28    2
## 316    28    2
## 317    29    2
## 318    29    2
## 319    29    2
## 320    29    2
## 321    29    2
## 322    29    2
## 323    29    2
## 324    29    2
## 325    29    2
## 326    29    2
## 327    29    2
## 328    29    2
## 329    30    2
## 330    30    2
## 331    30    2
## 332    30    2
## 333    30    2
## 334    30    2
## 335    30    2
## 336    30    2
## 337    30    2
## 338    30    2
## 339    30    2
## 340    30    2
## 341    31    3
## 342    31    3
## 343    31    3
## 344    31    3
## 345    31    3
## 346    31    3
## 347    31    3
## 348    31    3
## 349    31    3
## 350    31    3
## 351    31    3
## 352    31    3
## 353    32    3
## 354    32    3
## 355    32    3
## 356    32    3
## 357    32    3
## 358    32    3
## 359    32    3
## 360    32    3
## 361    32    3
## 362    32    3
## 363    32    3
## 364    32    3
## 365    33    3
## 366    33    3
## 367    33    3
## 368    33    3
## 369    33    3
## 370    33    3
## 371    33    3
## 372    33    3
## 373    33    3
## 374    33    3
## 375    33    3
## 376    33    3
## 377    34    3
## 378    34    3
## 379    34    3
## 380    34    3
## 381    34    3
## 382    34    3
## 383    34    3
## 384    34    3
## 385    34    3
## 386    34    3
## 387    34    3
## 388    34    3
## 389    35    3
## 390    35    3
## 391    35    3
## 392    35    3
## 393    35    3
## 394    35    3
## 395    35    3
## 396    35    3
## 397    35    3
## 398    35    3
## 399    35    3
## 400    35    3
## 401    36    3
## 402    36    3
## 403    36    3
## 404    36    3
## 405    36    3
## 406    36    3
## 407    36    3
## 408    36    3
## 409    36    3
## 410    36    3
## 411    36    3
## 412    36    3
## 413    37    3
## 414    37    3
## 415    37    3
## 416    37    3
## 417    37    3
## 418    37    3
## 419    37    3
## 420    37    3
## 421    37    3
## 422    37    3
## 423    37    3
## 424    37    3
## 425    38    3
## 426    38    3
## 427    38    3
## 428    38    3
## 429    38    3
## 430    38    3
## 431    38    3
## 432    38    3
## 433    38    3
## 434    38    3
## 435    38    3
## 436    38    3
## 437    39    3
## 438    39    3
## 439    39    3
## 440    39    3
## 441    39    3
## 442    39    3
## 443    39    3
## 444    39    3
## 445    39    3
## 446    39    3
## 447    39    3
## 448    39    3
## 449    40    3
## 450    40    3
## 451    40    3
## 452    40    3
## 453    40    3
## 454    40    3
## 455    40    3
## 456    40    3
## 457    40    3
## 458    40    3
## 459    40    3
## 460    40    3
## 461    41    4
## 462    41    4
## 463    41    4
## 464    41    4
## 465    41    4
## 466    41    4
## 467    41    4
## 468    41    4
## 469    41    4
## 470    41    4
## 471    41    4
## 472    41    4
## 473    42    4
## 474    42    4
## 475    42    4
## 476    42    4
## 477    42    4
## 478    42    4
## 479    42    4
## 480    42    4
## 481    42    4
## 482    42    4
## 483    42    4
## 484    42    4
## 485    43    4
## 486    43    4
## 487    43    4
## 488    43    4
## 489    43    4
## 490    43    4
## 491    43    4
## 492    43    4
## 493    43    4
## 494    43    4
## 495    43    4
## 496    43    4
## 497    44    4
## 498    44    4
## 499    44    4
## 500    44    4
## 501    44    4
## 502    44    4
## 503    44    4
## 504    44    4
## 505    44    4
## 506    44    4
## 507    45    4
## 508    45    4
## 509    45    4
## 510    45    4
## 511    45    4
## 512    45    4
## 513    45    4
## 514    45    4
## 515    45    4
## 516    45    4
## 517    45    4
## 518    45    4
## 519    46    4
## 520    46    4
## 521    46    4
## 522    46    4
## 523    46    4
## 524    46    4
## 525    46    4
## 526    46    4
## 527    46    4
## 528    46    4
## 529    46    4
## 530    46    4
## 531    47    4
## 532    47    4
## 533    47    4
## 534    47    4
## 535    47    4
## 536    47    4
## 537    47    4
## 538    47    4
## 539    47    4
## 540    47    4
## 541    47    4
## 542    47    4
## 543    48    4
## 544    48    4
## 545    48    4
## 546    48    4
## 547    48    4
## 548    48    4
## 549    48    4
## 550    48    4
## 551    48    4
## 552    48    4
## 553    48    4
## 554    48    4
## 555    49    4
## 556    49    4
## 557    49    4
## 558    49    4
## 559    49    4
## 560    49    4
## 561    49    4
## 562    49    4
## 563    49    4
## 564    49    4
## 565    49    4
## 566    49    4
## 567    50    4
## 568    50    4
## 569    50    4
## 570    50    4
## 571    50    4
## 572    50    4
## 573    50    4
## 574    50    4
## 575    50    4
## 576    50    4
## 577    50    4
## 578    50    4</code></pre>
<p>One thing to note is that if you select a <strong>single</strong> column, R will return a vector rather than a dataframe.</p>
<pre class="r"><code>ChickWeight[ ,4]</code></pre>
<pre><code>##   [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
##  [36] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
##  [71] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## [106] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## [141] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## [176] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
## [211] 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
## [246] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
## [281] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
## [316] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3
## [351] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
## [386] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
## [421] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
## [456] 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
## [491] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
## [526] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
## [561] 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
## Levels: 1 2 3 4</code></pre>
<p>If you would like a data frame instead, you can add the optional argument <code>drop = FALSE</code> between brackets.</p>
<pre class="r"><code>ChickWeight[ , 4, drop = FALSE]</code></pre>
<pre><code>##     Diet
## 1      1
## 2      1
## 3      1
## 4      1
## 5      1
## 6      1
## 7      1
## 8      1
## 9      1
## 10     1
## 11     1
## 12     1
## 13     1
## 14     1
## 15     1
## 16     1
## 17     1
## 18     1
## 19     1
## 20     1
## 21     1
## 22     1
## 23     1
## 24     1
## 25     1
## 26     1
## 27     1
## 28     1
## 29     1
## 30     1
## 31     1
## 32     1
## 33     1
## 34     1
## 35     1
## 36     1
## 37     1
## 38     1
## 39     1
## 40     1
## 41     1
## 42     1
## 43     1
## 44     1
## 45     1
## 46     1
## 47     1
## 48     1
## 49     1
## 50     1
## 51     1
## 52     1
## 53     1
## 54     1
## 55     1
## 56     1
## 57     1
## 58     1
## 59     1
## 60     1
## 61     1
## 62     1
## 63     1
## 64     1
## 65     1
## 66     1
## 67     1
## 68     1
## 69     1
## 70     1
## 71     1
## 72     1
## 73     1
## 74     1
## 75     1
## 76     1
## 77     1
## 78     1
## 79     1
## 80     1
## 81     1
## 82     1
## 83     1
## 84     1
## 85     1
## 86     1
## 87     1
## 88     1
## 89     1
## 90     1
## 91     1
## 92     1
## 93     1
## 94     1
## 95     1
## 96     1
## 97     1
## 98     1
## 99     1
## 100    1
## 101    1
## 102    1
## 103    1
## 104    1
## 105    1
## 106    1
## 107    1
## 108    1
## 109    1
## 110    1
## 111    1
## 112    1
## 113    1
## 114    1
## 115    1
## 116    1
## 117    1
## 118    1
## 119    1
## 120    1
## 121    1
## 122    1
## 123    1
## 124    1
## 125    1
## 126    1
## 127    1
## 128    1
## 129    1
## 130    1
## 131    1
## 132    1
## 133    1
## 134    1
## 135    1
## 136    1
## 137    1
## 138    1
## 139    1
## 140    1
## 141    1
## 142    1
## 143    1
## 144    1
## 145    1
## 146    1
## 147    1
## 148    1
## 149    1
## 150    1
## 151    1
## 152    1
## 153    1
## 154    1
## 155    1
## 156    1
## 157    1
## 158    1
## 159    1
## 160    1
## 161    1
## 162    1
## 163    1
## 164    1
## 165    1
## 166    1
## 167    1
## 168    1
## 169    1
## 170    1
## 171    1
## 172    1
## 173    1
## 174    1
## 175    1
## 176    1
## 177    1
## 178    1
## 179    1
## 180    1
## 181    1
## 182    1
## 183    1
## 184    1
## 185    1
## 186    1
## 187    1
## 188    1
## 189    1
## 190    1
## 191    1
## 192    1
## 193    1
## 194    1
## 195    1
## 196    1
## 197    1
## 198    1
## 199    1
## 200    1
## 201    1
## 202    1
## 203    1
## 204    1
## 205    1
## 206    1
## 207    1
## 208    1
## 209    1
## 210    1
## 211    1
## 212    1
## 213    1
## 214    1
## 215    1
## 216    1
## 217    1
## 218    1
## 219    1
## 220    1
## 221    2
## 222    2
## 223    2
## 224    2
## 225    2
## 226    2
## 227    2
## 228    2
## 229    2
## 230    2
## 231    2
## 232    2
## 233    2
## 234    2
## 235    2
## 236    2
## 237    2
## 238    2
## 239    2
## 240    2
## 241    2
## 242    2
## 243    2
## 244    2
## 245    2
## 246    2
## 247    2
## 248    2
## 249    2
## 250    2
## 251    2
## 252    2
## 253    2
## 254    2
## 255    2
## 256    2
## 257    2
## 258    2
## 259    2
## 260    2
## 261    2
## 262    2
## 263    2
## 264    2
## 265    2
## 266    2
## 267    2
## 268    2
## 269    2
## 270    2
## 271    2
## 272    2
## 273    2
## 274    2
## 275    2
## 276    2
## 277    2
## 278    2
## 279    2
## 280    2
## 281    2
## 282    2
## 283    2
## 284    2
## 285    2
## 286    2
## 287    2
## 288    2
## 289    2
## 290    2
## 291    2
## 292    2
## 293    2
## 294    2
## 295    2
## 296    2
## 297    2
## 298    2
## 299    2
## 300    2
## 301    2
## 302    2
## 303    2
## 304    2
## 305    2
## 306    2
## 307    2
## 308    2
## 309    2
## 310    2
## 311    2
## 312    2
## 313    2
## 314    2
## 315    2
## 316    2
## 317    2
## 318    2
## 319    2
## 320    2
## 321    2
## 322    2
## 323    2
## 324    2
## 325    2
## 326    2
## 327    2
## 328    2
## 329    2
## 330    2
## 331    2
## 332    2
## 333    2
## 334    2
## 335    2
## 336    2
## 337    2
## 338    2
## 339    2
## 340    2
## 341    3
## 342    3
## 343    3
## 344    3
## 345    3
## 346    3
## 347    3
## 348    3
## 349    3
## 350    3
## 351    3
## 352    3
## 353    3
## 354    3
## 355    3
## 356    3
## 357    3
## 358    3
## 359    3
## 360    3
## 361    3
## 362    3
## 363    3
## 364    3
## 365    3
## 366    3
## 367    3
## 368    3
## 369    3
## 370    3
## 371    3
## 372    3
## 373    3
## 374    3
## 375    3
## 376    3
## 377    3
## 378    3
## 379    3
## 380    3
## 381    3
## 382    3
## 383    3
## 384    3
## 385    3
## 386    3
## 387    3
## 388    3
## 389    3
## 390    3
## 391    3
## 392    3
## 393    3
## 394    3
## 395    3
## 396    3
## 397    3
## 398    3
## 399    3
## 400    3
## 401    3
## 402    3
## 403    3
## 404    3
## 405    3
## 406    3
## 407    3
## 408    3
## 409    3
## 410    3
## 411    3
## 412    3
## 413    3
## 414    3
## 415    3
## 416    3
## 417    3
## 418    3
## 419    3
## 420    3
## 421    3
## 422    3
## 423    3
## 424    3
## 425    3
## 426    3
## 427    3
## 428    3
## 429    3
## 430    3
## 431    3
## 432    3
## 433    3
## 434    3
## 435    3
## 436    3
## 437    3
## 438    3
## 439    3
## 440    3
## 441    3
## 442    3
## 443    3
## 444    3
## 445    3
## 446    3
## 447    3
## 448    3
## 449    3
## 450    3
## 451    3
## 452    3
## 453    3
## 454    3
## 455    3
## 456    3
## 457    3
## 458    3
## 459    3
## 460    3
## 461    4
## 462    4
## 463    4
## 464    4
## 465    4
## 466    4
## 467    4
## 468    4
## 469    4
## 470    4
## 471    4
## 472    4
## 473    4
## 474    4
## 475    4
## 476    4
## 477    4
## 478    4
## 479    4
## 480    4
## 481    4
## 482    4
## 483    4
## 484    4
## 485    4
## 486    4
## 487    4
## 488    4
## 489    4
## 490    4
## 491    4
## 492    4
## 493    4
## 494    4
## 495    4
## 496    4
## 497    4
## 498    4
## 499    4
## 500    4
## 501    4
## 502    4
## 503    4
## 504    4
## 505    4
## 506    4
## 507    4
## 508    4
## 509    4
## 510    4
## 511    4
## 512    4
## 513    4
## 514    4
## 515    4
## 516    4
## 517    4
## 518    4
## 519    4
## 520    4
## 521    4
## 522    4
## 523    4
## 524    4
## 525    4
## 526    4
## 527    4
## 528    4
## 529    4
## 530    4
## 531    4
## 532    4
## 533    4
## 534    4
## 535    4
## 536    4
## 537    4
## 538    4
## 539    4
## 540    4
## 541    4
## 542    4
## 543    4
## 544    4
## 545    4
## 546    4
## 547    4
## 548    4
## 549    4
## 550    4
## 551    4
## 552    4
## 553    4
## 554    4
## 555    4
## 556    4
## 557    4
## 558    4
## 559    4
## 560    4
## 561    4
## 562    4
## 563    4
## 564    4
## 565    4
## 566    4
## 567    4
## 568    4
## 569    4
## 570    4
## 571    4
## 572    4
## 573    4
## 574    4
## 575    4
## 576    4
## 577    4
## 578    4</code></pre>
</div>
<div id="logical-1" class="section level3">
<h3>Logical</h3>
<p>If you supply a vector of <code>TRUE</code>S and <code>FALSE</code>S as your index, R will match each <code>TRUE</code> and <code>FALSE</code> to a row or column in your data frame. R will then return each row corresponding to a <code>TRUE</code>. In the image below, the command would return just the numbers 1, 6, and 5.</p>
<center>
<img src="Figures/TF_subset.png" width="500" />
</center>
<p><br></p>
<p>It may help to imagine R using the logical vector as a <em>filter</em> which asks, “Should I return this particular value?”, and then consulting the corresponding logical vector for its answer (<code>TRUE</code> = yes, <code>FALSE</code> = no).</p>
<p>You could create logical vectors directly using <code>c()</code>. For example, I could could access every other value of <code>a</code> below using my own logical index.</p>
<pre class="r"><code>a &lt;- c(1, 2, 3, 4, 5)
a[c(TRUE, FALSE, TRUE, FALSE, TRUE)]  # Return every other value</code></pre>
<pre><code>## [1] 1 3 5</code></pre>
<p>As you can see, R returns all values of the vector <code>a</code> for which the logical vector is <code>TRUE</code>. Generally, this system works best when your logical vector is as long as the dimension you are trying to subset. Take our <code>deck</code> of cards. Say I wanted to retain either just the first 2 columns or just the first 13 values.</p>
<pre class="r"><code># Retain only first 2 columns
deck[1, c(TRUE, TRUE, FALSE)] </code></pre>
<pre><code>##   face   suit
## 1  ace hearts</code></pre>
<pre class="r"><code># Retain only first 10 rows
rows &lt;- c(TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, F, F, F,
          F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, 
          F, F, F, F, F, F, F, F, F, F, F, F, F)
deck[rows, ]</code></pre>
<pre><code>##     face   suit value
## 1    ace hearts     1
## 2    two hearts     2
## 3  three hearts     3
## 4   four hearts     4
## 5   five hearts     5
## 6    six hearts     6
## 7  seven hearts     7
## 8  eight hearts     8
## 9   nine hearts     9
## 10   ten hearts    10</code></pre>
<p>This may seem highly impratical - who wants to type out so many <code>TRUE</code>S and <code>FALSE</code>S. However, this technique will become much more powerful when we explore</p>
</div>
<div id="names-1" class="section level3">
<h3>Names</h3>
<p>Finally, you can ask for the elements you want by name if the object has a name attribute. Data frames almost always have names, making this a convenient way to access specific variables when familiar with the data.</p>
<pre class="r"><code># Just the face and suit for row 1
deck[1, c(&quot;face&quot;, &quot;suit&quot;)]</code></pre>
<pre><code>##   face   suit
## 1  ace hearts</code></pre>
<pre class="r"><code># the entire value column
deck[ , &quot;value&quot;]</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13  1  2  3  4  5  6  7  8  9 10
## [24] 11 12 13  1  2  3  4  5  6  7  8  9 10 11 12 13  1  2  3  4  5  6  7
## [47]  8  9 10 11 12 13</code></pre>
</div>
<div id="the-dollar-sign-and-double-brackets" class="section level3">
<h3>The Dollar Sign (<code>$</code>) and Double Brackets (<code>[[]]</code>)</h3>
<p>Data frames and lists obey an optional second system of notation. You can extract values from either with the <code>$</code> syntax in the form of <code>df$name</code> where <code>df</code> is the name of the dataframe and <code>name</code> is the name of the column. RStudio has a nice auto-complete feature where using <code>$</code> will bring up a list of available elements within the object. This operation will then return the column you want as a vector. Let’s pull out just the <code>values</code> column from our <code>deck</code>.</p>
<pre class="r"><code>deck$value</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13  1  2  3  4  5  6  7  8  9 10
## [24] 11 12 13  1  2  3  4  5  6  7  8  9 10 11 12 13  1  2  3  4  5  6  7
## [47]  8  9 10 11 12 13</code></pre>
<p>The <code>$</code> notation is incredibly useful. Because <code>$</code> returns a vector, you can easily run all kinds of functions on it, such as <code>mean</code> or <code>median</code>. In R, these functions expect a vector of values as input, and <code>deck$value</code> delivers your data in just the right format.</p>
<pre class="r"><code># what is the mean value of a deck of cards?
mean(deck$value)</code></pre>
<pre><code>## [1] 7</code></pre>
<pre class="r"><code># What is the median?
median(deck$value)</code></pre>
<pre><code>## [1] 7</code></pre>
<p>You can use the same <code>$</code> notation with the elements of a list, if they have names. This notation has an advantage with lists, too. If you subset a list in the usual way, R will return a new <em>list</em> that has the elements you requested. This is true even if you only request a single element. Let’s see how this works with our GOT list from earlier.</p>
<pre class="r"><code>GOT &lt;- list(showname = &quot;Game of Thrones&quot;,
            seasons = 8,
            characters = c(&quot;Tyrion Lannister&quot;, &quot;Jaime Lannister&quot;, &quot;Bran Stark&quot;, &quot;Arya Stark&quot;,
                           &quot;Jon Snow&quot;, &quot;Daenerys Targaryen&quot;),
            reviews = c(9, 10, 9, 10, 10, 8))
GOT</code></pre>
<pre><code>## $showname
## [1] &quot;Game of Thrones&quot;
## 
## $seasons
## [1] 8
## 
## $characters
## [1] &quot;Tyrion Lannister&quot;   &quot;Jaime Lannister&quot;    &quot;Bran Stark&quot;        
## [4] &quot;Arya Stark&quot;         &quot;Jon Snow&quot;           &quot;Daenerys Targaryen&quot;
## 
## $reviews
## [1]  9 10  9 10 10  8</code></pre>
<p>And then subset the <code>review</code> element.</p>
<pre class="r"><code>GOT[4]</code></pre>
<pre><code>## $reviews
## [1]  9 10  9 10 10  8</code></pre>
<p>The result is actually a smaller <em>list</em> with one element: the vector <code>c(9, 10, 9, 10, 10, 8)</code>. This can be annoying because many R functions do not work with lists. For example, if we wanted the average review we might try to run <code>mean(GOT[4])</code> but this will just throw an error. It would be frustrating if once data were put into a list you could never pull it out as a vector.</p>
<pre class="r"><code>mean(GOT[4])</code></pre>
<pre><code>## Warning in mean.default(GOT[4]): argument is not numeric or logical:
## returning NA</code></pre>
<pre><code>## [1] NA</code></pre>
<p>When you use the <code>$</code> notation instead, R will return the selected values as they are with the list structure removed. This will allow you to feed the results directly into many functions.</p>
<pre class="r"><code>mean(GOT$reviews)</code></pre>
<pre><code>## [1] 9.333333</code></pre>
<p>You can also directly extract elements from the list using a <code>[[]]</code> bracket and a corresponding index. I like to think of the extra bracket as indicating you are diving deeper into an R object. You can provide either names (if the list has names) or an iteger specifying which element of the list you desire. Either notation will do the same things as the <code>$</code> symbol. Returning to our example.</p>
<pre class="r"><code>GOT[[4]]           # by integer</code></pre>
<pre><code>## [1]  9 10  9 10 10  8</code></pre>
<pre class="r"><code>GOT[[&quot;reviews&quot;]]   # by name</code></pre>
<pre><code>## [1]  9 10  9 10 10  8</code></pre>
<p>In other words, if you subset a list with single-bracket notation, R will return a smaller list. If you subset a list with double-bracket notation, R will return just the value that were inside an element of the list (often a vector).</p>
<p>This also means if you use a single bracket to return a list, you can subsequently use more brackets it to pull out a vector. While not practical, this just illustrate how R handles objects. Single-bracketing a list just returns another list.</p>
<pre class="r"><code>GOT[4][[1]]</code></pre>
<pre><code>## [1]  9 10  9 10 10  8</code></pre>
<p>Sometimes you may have a <strong>recursive list</strong>, or a list inside a list. If you extract an interior list with <code>[[]]</code>, you will need to use a second set <code>[[]]</code> to extract elements from the interior list. Take the following example.</p>
<pre class="r"><code># create a list within a list
lst &lt;- list(x = 1:5, a = list(y = 6:10, z = 11:15))

#Extract just the interior list, a
lst[[2]] </code></pre>
<pre><code>## $y
## [1]  6  7  8  9 10
## 
## $z
## [1] 11 12 13 14 15</code></pre>
<pre class="r"><code>#Extract interior list as well as its first vector, y
lst[[2]][[1]]</code></pre>
<pre><code>## [1]  6  7  8  9 10</code></pre>
<p>The differences between <code>[]</code> and <code>[[]]</code> (or, equivalent, the <code>$</code> operator) are subtle but important. In the R community, there is a popular way to think about it (see image below). Imagine that each list is a train and each element is a train car. When you use single brackets, R selects individual train cars and returns them as a new train. Each car keeps its contents, but those contents are still inside a train car (i.e., a list). When you use double brackets, R actually unloads the car and gives you back the contents.</p>
<center>
<img src="Figures/train_list_extraction.png" width="400" />
</center>
<p><br></p>
</div>
<div id="exercise---indices" class="section level3">
<h3>Exercise - Indices</h3>
<ol style="list-style-type: decimal">
<li>Create a vector <code>x1</code> from 1:5. Then, create a logical vector with 3 TRUE followed by 2 FALSE and use it to subset vector <code>x1</code>.</li>
<li>Carry out the following subsets of vector <code>x &lt;- 1:10</code></li>
</ol>
<ul>
<li>Keep first through fourth element, plus seventh element</li>
<li>Keep first through eight element, plus tenth element</li>
<li>Keep all elements with values greater than five</li>
<li>Keep all elements evenly divisible by three</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>Examine the first 6 rows of <code>msleep</code> using the <code>head</code> function. Next, pull out the name and genus for the first six animals using integers.</li>
<li>Return everything <strong>but</strong> the first 2 rows and column in <code>msleep</code>.</li>
<li>Print out a list of column names for <code>msleep</code> with the <code>names</code> function. Then, pull out 3 variables which seem interesting using their names as column indexes.</li>
<li>Using <code>cbind</code> and the <code>$</code> operator, extract the three sleep variables from <code>msleep</code> and combine into a single matrix object called <code>sleep</code>. Bonus: convert this matrix to a dataframe.</li>
</ol>
<pre class="r"><code>#1 problem
x1 &lt;- 1:5
log &lt;- c(rep(TRUE, 3), rep(FALSE, 2))
x1[log]</code></pre>
<pre><code>## [1] 1 2 3</code></pre>
<pre class="r"><code>#2 problem
x &lt;- c(1:10)

#three different ways to subset same values
x[c(1, 2, 3, 4, 7)]</code></pre>
<pre><code>## [1] 1 2 3 4 7</code></pre>
<pre class="r"><code>x[c(1:4, 7)]</code></pre>
<pre><code>## [1] 1 2 3 4 7</code></pre>
<pre class="r"><code>x[c(seq(from = 1, to = 4), 7)]</code></pre>
<pre><code>## [1] 1 2 3 4 7</code></pre>
<pre class="r"><code>#same result, but 2nd expression simpler
x[c(1:8, 10)]</code></pre>
<pre><code>## [1]  1  2  3  4  5  6  7  8 10</code></pre>
<pre class="r"><code>x[-9]</code></pre>
<pre><code>## [1]  1  2  3  4  5  6  7  8 10</code></pre>
<pre class="r"><code>#logical subset
x[x &gt; 5]</code></pre>
<pre><code>## [1]  6  7  8  9 10</code></pre>
<pre class="r"><code>#modulus to return a vector showing remainder. Result = 0 when 3 cleanly divides. 
x[x %% 3 == 0]</code></pre>
<pre><code>## [1] 3 6 9</code></pre>
<pre class="r"><code>#3 problem
head(msleep)</code></pre>
<pre><code>## # A tibble: 6 x 11
##   name  genus vore  order conservation sleep_total sleep_rem sleep_cycle
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
## 1 Chee~ Acin~ carni Carn~ lc                  12.1      NA        NA    
## 2 Owl ~ Aotus omni  Prim~ &lt;NA&gt;                17         1.8      NA    
## 3 Moun~ Aplo~ herbi Rode~ nt                  14.4       2.4      NA    
## 4 Grea~ Blar~ omni  Sori~ lc                  14.9       2.3       0.133
## 5 Cow   Bos   herbi Arti~ domesticated         4         0.7       0.667
## 6 Thre~ Brad~ herbi Pilo~ &lt;NA&gt;                14.4       2.2       0.767
## # ... with 3 more variables: awake &lt;dbl&gt;, brainwt &lt;dbl&gt;, bodywt &lt;dbl&gt;</code></pre>
<pre class="r"><code>msleep[1:6, 1:2]</code></pre>
<pre><code>## # A tibble: 6 x 2
##   name                       genus     
##   &lt;chr&gt;                      &lt;chr&gt;     
## 1 Cheetah                    Acinonyx  
## 2 Owl monkey                 Aotus     
## 3 Mountain beaver            Aplodontia
## 4 Greater short-tailed shrew Blarina   
## 5 Cow                        Bos       
## 6 Three-toed sloth           Bradypus</code></pre>
<pre class="r"><code>#4 Problem
msleep[c(-1,-2), c(-1,-2)] # One way</code></pre>
<pre><code>## # A tibble: 81 x 9
##    vore  order conservation sleep_total sleep_rem sleep_cycle awake
##    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt;
##  1 herbi Rode~ nt                  14.4       2.4      NA       9.6
##  2 omni  Sori~ lc                  14.9       2.3       0.133   9.1
##  3 herbi Arti~ domesticated         4         0.7       0.667  20  
##  4 herbi Pilo~ &lt;NA&gt;                14.4       2.2       0.767   9.6
##  5 carni Carn~ vu                   8.7       1.4       0.383  15.3
##  6 &lt;NA&gt;  Rode~ &lt;NA&gt;                 7        NA        NA      17  
##  7 carni Carn~ domesticated        10.1       2.9       0.333  13.9
##  8 herbi Arti~ lc                   3        NA        NA      21  
##  9 herbi Arti~ lc                   5.3       0.6      NA      18.7
## 10 herbi Rode~ domesticated         9.4       0.8       0.217  14.6
## # ... with 71 more rows, and 2 more variables: brainwt &lt;dbl&gt;, bodywt &lt;dbl&gt;</code></pre>
<pre class="r"><code>msleep[-1:-2, -1:-2]         # Another way</code></pre>
<pre><code>## # A tibble: 81 x 9
##    vore  order conservation sleep_total sleep_rem sleep_cycle awake
##    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt;
##  1 herbi Rode~ nt                  14.4       2.4      NA       9.6
##  2 omni  Sori~ lc                  14.9       2.3       0.133   9.1
##  3 herbi Arti~ domesticated         4         0.7       0.667  20  
##  4 herbi Pilo~ &lt;NA&gt;                14.4       2.2       0.767   9.6
##  5 carni Carn~ vu                   8.7       1.4       0.383  15.3
##  6 &lt;NA&gt;  Rode~ &lt;NA&gt;                 7        NA        NA      17  
##  7 carni Carn~ domesticated        10.1       2.9       0.333  13.9
##  8 herbi Arti~ lc                   3        NA        NA      21  
##  9 herbi Arti~ lc                   5.3       0.6      NA      18.7
## 10 herbi Rode~ domesticated         9.4       0.8       0.217  14.6
## # ... with 71 more rows, and 2 more variables: brainwt &lt;dbl&gt;, bodywt &lt;dbl&gt;</code></pre>
<pre class="r"><code># 5 Problem
names(msleep)</code></pre>
<pre><code>##  [1] &quot;name&quot;         &quot;genus&quot;        &quot;vore&quot;         &quot;order&quot;       
##  [5] &quot;conservation&quot; &quot;sleep_total&quot;  &quot;sleep_rem&quot;    &quot;sleep_cycle&quot; 
##  [9] &quot;awake&quot;        &quot;brainwt&quot;      &quot;bodywt&quot;</code></pre>
<pre class="r"><code>msleep[, c(&quot;name&quot;, &quot;conservation&quot;, &quot;sleep_total&quot;)]</code></pre>
<pre><code>## # A tibble: 83 x 3
##    name                       conservation sleep_total
##    &lt;chr&gt;                      &lt;chr&gt;              &lt;dbl&gt;
##  1 Cheetah                    lc                  12.1
##  2 Owl monkey                 &lt;NA&gt;                17  
##  3 Mountain beaver            nt                  14.4
##  4 Greater short-tailed shrew lc                  14.9
##  5 Cow                        domesticated         4  
##  6 Three-toed sloth           &lt;NA&gt;                14.4
##  7 Northern fur seal          vu                   8.7
##  8 Vesper mouse               &lt;NA&gt;                 7  
##  9 Dog                        domesticated        10.1
## 10 Roe deer                   lc                   3  
## # ... with 73 more rows</code></pre>
<pre class="r"><code># 6 Problem
sleep &lt;- cbind(msleep$sleep_total, msleep$sleep_rem, msleep$sleep_cycle)
sleep &lt;- as.data.frame(sleep)</code></pre>
</div>
<div id="logical-tests" class="section level2">
<h2>Logical Tests</h2>
<p>Recall R’s logical index system where you can select values with a vector of <code>TRUE</code>S and <code>FALSE</code>S. It is desirable for te vector to be of the same length as the dimension you wish to subset, otherwise R will recycle the logical test. R will return ever element that matches <code>TRUE</code>.</p>
<pre class="r"><code>vec &lt;- 1:5
log &lt;- c(T, T, F, F, F)
vec[log]</code></pre>
<pre><code>## [1] 1 2</code></pre>
<p>However, creating logical vectors with <code>c()</code> is tedious. Instead, it is best to come up with <strong>logical tests</strong> which will create logical vectors from <em>existing vectors</em> using comparison operators, like <code>&lt;</code> (less than), <code>==</code> (equals to), and <code>!=</code> (not equal to). These tests ask questions of your data, such as is “one less than two”, <code>1 &lt; 2</code>, or is “three plus three equal to five?”, `3 + 3 == 5’. R provides seven logical operators you can use to make comparisons.</p>
<table>
<thead>
<tr class="header">
<th align="left">Operator</th>
<th align="left">Syntax</th>
<th align="left">Test</th>
<th align="left">Example</th>
<th align="left">Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>&gt;</code></td>
<td align="left"><code>a &gt; b</code></td>
<td align="left">Is <code>a</code> greater than <code>b</code>?</td>
<td align="left"><code>1 &gt; 1</code></td>
<td align="left">FALSE</td>
</tr>
<tr class="even">
<td align="left"><code>&gt;=</code></td>
<td align="left"><code>a &gt;= b</code></td>
<td align="left">Is <code>a</code> greater than or equal to <code>b</code>?</td>
<td align="left"><code>1 &gt;= 1</code></td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left"><code>&lt;</code></td>
<td align="left"><code>a &lt; b</code></td>
<td align="left">Is <code>a</code> less than <code>b</code>?</td>
<td align="left"><code>1 &lt; 1</code></td>
<td align="left">FALSE</td>
</tr>
<tr class="even">
<td align="left"><code>&lt;=</code></td>
<td align="left"><code>a &lt;= b</code></td>
<td align="left">Is <code>a</code> less than or equal to <code>b</code>?</td>
<td align="left"><code>1 &lt;= 1</code></td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left"><code>==</code></td>
<td align="left"><code>a == b</code></td>
<td align="left">Is <code>a</code> equal to <code>b</code>?</td>
<td align="left"><code>1 == 1</code></td>
<td align="left">TRUE</td>
</tr>
<tr class="even">
<td align="left"><code>!=</code></td>
<td align="left"><code>a != b</code></td>
<td align="left">Is <code>a</code> not equal to <code>b</code>?</td>
<td align="left"><code>1 != 1</code></td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left"><code>%in%</code></td>
<td align="left"><code>a %in% c(a, b, c)</code></td>
<td align="left">Is <code>a</code> in the group <code>c(a, b, c)</code>?</td>
<td align="left"><code>1 %in% c(2, 3, 4)</code></td>
<td align="left">FALSE</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>Each operator returns a <code>TRUE</code> or a <code>FALSE</code>. If you use an operator to compare vectors, R will do element-wise comparisons—just like it does with the arithmetic operators.</p>
<pre class="r"><code>1 &gt; 2</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>1 &gt; c(0, 1, 2)</code></pre>
<pre><code>## [1]  TRUE FALSE FALSE</code></pre>
<pre class="r"><code>c(1, 2, 3) == c(3, 2, 1)</code></pre>
<pre><code>## [1] FALSE  TRUE FALSE</code></pre>
<p>The <code>%in%</code> is unique in that it does not do normal element-wise execution. <code>%in%</code> test if the value(s) on the left side are in the vector on the right side. If you provide a vector on the left side, <code>%in%</code> will <em>not</em> pair up the values on the left with values on the right and do element-wise tests. Instead, <code>%in%</code> will independently test whether each value on the left is <em>somewhere</em> in the vector on the right.</p>
<pre class="r"><code>1 %in% c(3, 4, 5)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>1:2 %in% c(3, 4, 5)</code></pre>
<pre><code>## [1] FALSE FALSE</code></pre>
<pre class="r"><code>1:3 %in% c(3, 4, 5)</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE</code></pre>
<p>You can also test whether a much longer vector is contained within a shorter vector. This can be used for figuring out if and where a certain word, factor level, or value exists somewhere inside a variable (although use of <code>which</code> would be simpler).</p>
<pre class="r"><code>c(&quot;dog&quot;, &quot;cat&quot;, &quot;mouse&quot;, &quot;hawk&quot;) %in% &quot;dog&quot;</code></pre>
<pre><code>## [1]  TRUE FALSE FALSE FALSE</code></pre>
<p>We will create a small subset of <code>Cars93</code> called <code>sm_cars</code> to illustrate what logical tests are doing behind the scenes. Note we are now using the <code>$</code> operator to pull out vectors to be used directly in logical tests.</p>
<pre class="r"><code>library(MASS)</code></pre>
<pre><code>## 
## Attaching package: &#39;MASS&#39;</code></pre>
<pre><code>## The following object is masked _by_ &#39;.GlobalEnv&#39;:
## 
##     survey</code></pre>
<pre><code>## The following object is masked from &#39;package:dplyr&#39;:
## 
##     select</code></pre>
<pre class="r"><code>sm_cars &lt;- Cars93[1:10, c(1:3, 6:7, 9:10, 12)]

# Which cars cost less than $20,000?
sm_cars$Max.Price</code></pre>
<pre><code>##  [1] 18.8 38.7 32.3 44.6 36.2 17.3 21.7 24.9 26.3 36.3</code></pre>
<pre class="r"><code>sm_cars$Max.Price &lt; 20.0</code></pre>
<pre><code>##  [1]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code># Which cars have at least 25 mpg in the city or higher?
sm_cars$MPG.city</code></pre>
<pre><code>##  [1] 25 18 20 19 22 22 19 16 19 16</code></pre>
<pre class="r"><code>sm_cars$MPG.city &gt;= 25</code></pre>
<pre><code>##  [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code># Which cars are made by Audi?
sm_cars$Manufacturer</code></pre>
<pre><code>##  [1] Acura    Acura    Audi     Audi     BMW      Buick    Buick   
##  [8] Buick    Buick    Cadillac
## 32 Levels: Acura Audi BMW Buick Cadillac Chevrolet Chrylser ... Volvo</code></pre>
<pre class="r"><code>sm_cars$Manufacturer == &quot;Audi&quot;</code></pre>
<pre><code>##  [1] FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE</code></pre>
<p>Note in the last example you test for equality with a double equals sign, <code>==</code>, and not a single equals sign, <code>=</code>, which is another way to write <code>&lt;-</code>. It is easy to forget and use <code>a = b</code> to test if <code>a</code> equals <code>b</code>. However, R will not return a <code>TRUE</code> or <code>FALSE</code> in this case because it won’t have to: <code>a</code> now <em>does</em> equal <code>b</code> because you just ran the equivalent of <code>a &lt;- b</code>. As a <strong>word of warning</strong>: it is generally bad form in the R community to use <code>=</code> as the assignment operator because R <em>also</em> uses <code>=</code> for associating function arguments with values(as in <code>mean(1:4, na.rm = T)</code>). Mixing these functions can create ambiguity in your code, hence better to keep separate.</p>
<p>You can also create logical vectors by comparing a vector to another vector. For example, say we found a list of competing prices for all vehicles from another dealership and wanted to compare which had a better offer.</p>
<pre class="r"><code>comp_price &lt;- c(20.1, 34.5, 33.7, 39.6, 45, 14.5, 15.5, 19.34, 22.2, 38)  # Competing prices for same vehicles from another dealer
comp_price &lt; sm_cars$Max.Price                                            # Are the competing offers better than </code></pre>
<pre><code>##  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE  TRUE FALSE</code></pre>
<p>Once you’ve created a logical vector using a comparison operator, you can use it to index any vector with the same length. Here, I’ll use a logical vector to get the rows of cars whose prices were less than $20,000.</p>
<pre class="r"><code>sm_cars[sm_cars$Max.Price &lt; 20, ]</code></pre>
<pre><code>##   Manufacturer   Model    Type Max.Price MPG.city     AirBags DriveTrain
## 1        Acura Integra   Small      18.8       25        None      Front
## 6        Buick Century Midsize      17.3       22 Driver only      Front
##   EngineSize
## 1        1.8
## 6        2.2</code></pre>
<p>If you recall, many R functions will interpret <code>TRUE</code> values as 1 and <code>FALSE</code> as 0. This allows us to easily answer questions like “How many values in a data vector are greater than 0?” or “What percentage of values are equal to 5?” by applying the <code>sum()</code> or <code>mean()</code> function to a logical vector. Say we desired to figure out how many cards in our <code>deck</code> are equal to “ace”?</p>
<pre class="r"><code># Create a logical test of which face values are equal to &quot;ace&quot;
deck$face == &quot;ace&quot;</code></pre>
<pre><code>##  [1]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [12] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [23] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE
## [34] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE
## [45] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code># Feed previous argument into sum function to count the number of TRUEs
sum(deck$face == &quot;ace&quot;)</code></pre>
<pre><code>## [1] 4</code></pre>
<p>To figure out the what percentage of cards this represents, we can do the following.</p>
<pre class="r"><code>mean(deck$face == &quot;ace&quot;)</code></pre>
<pre><code>## [1] 0.07692308</code></pre>
<p>Huzzah! This tells us we have 4 aces which represents about 8% of all possible cards. You can verify the last statement by running <code>4/52</code>.</p>
</div>
</div>
<div id="excercise---logical-operations" class="section level1">
<h1>Excercise - Logical Operations</h1>
<ol style="list-style-type: decimal">
<li>Create the a <code>w</code> vector with the values <code>c(-1, 0, 1)</code>. Next, create a logical test to evaluate whether each element of <code>w</code> is positive.</li>
<li>Pull out all rows from <code>decks</code> where suit is spades.</li>
<li>Count the number of aces in your <code>deck</code>? What proportion of the cards does this represent?</li>
<li>Based upon the max.price, how many cars in <code>Cars93</code> cost more than 40k?</li>
<li>Using the <code>%in%</code> operator, find out if any of the Models in <code>Cars93</code> are either “Camaro” or “Lexus”?</li>
</ol>
<pre class="r"><code># Solution 1
w &lt;- c(-1, 0, 1)
w &gt; 0</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE</code></pre>
<pre class="r"><code># Solution 1
deck[deck$suit == &quot;spades&quot;, ]</code></pre>
<pre><code>##     face   suit value
## 40   ace spades     1
## 41   two spades     2
## 42 three spades     3
## 43  four spades     4
## 44  five spades     5
## 45   six spades     6
## 46 seven spades     7
## 47 eight spades     8
## 48  nine spades     9
## 49   ten spades    10
## 50  jack spades    11
## 51 queen spades    12
## 52  king spades    13</code></pre>
<pre class="r"><code># Solution 2
sum(deck$face == &quot;ace&quot;)</code></pre>
<pre><code>## [1] 4</code></pre>
<pre class="r"><code># Solution 3
sum(Cars93$Max.Price &gt; 40)</code></pre>
<pre><code>## [1] 5</code></pre>
<pre class="r"><code># Solution 4
c(&quot;Camaro&quot;, &quot;Lexus&quot;) %in% Cars93$Model</code></pre>
<pre><code>## [1]  TRUE FALSE</code></pre>
<div id="boolean-operators" class="section level3">
<h3>Boolean Operators</h3>
<p>In addition to using a single comparison operator, you can combine <strong>multiple</strong> logical vectors using boolean operators like <em>and</em> (<code>&amp;</code>) and <em>or</em> (<code>|</code>). These operators will collapse the results of multiple logical tests into a single <code>TRUE</code> or <code>FALSE</code>. For example, the OR <code>|</code> operation will return <code>TRUE</code> if any of the logical vectors is <code>TRUE</code>, while the AND <code>&amp;</code> operation will only return <code>TRUE</code> if all of the values in the logical vectors is TRUE. This is especially powerful when you want to create logical vectors based on criteria from multiple vectors. R has six boolean operators.</p>
<table style="width:100%;">
<colgroup>
<col width="17%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Operator</th>
<th align="left">Syntax</th>
<th align="left">Test</th>
<th align="left">Example</th>
<th align="left">Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>&amp;</code></td>
<td align="left"><code>cond1 &amp; cond2</code></td>
<td align="left">Are both <code>cond1</code> and <code>cond2</code> true?</td>
<td align="left"><code>1 == 1 &amp; 1 == 2</code></td>
<td align="left">FALSE</td>
</tr>
<tr class="even">
<td align="left"><code>|</code></td>
<td align="left"><code>cond1 | cond2</code></td>
<td align="left">Is one or more of <code>cond1</code> and <code>cond2</code> true?</td>
<td align="left"><code>1 == 1 | 1 == 2</code></td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left"><code>!</code></td>
<td align="left"><code>!cond1</code></td>
<td align="left">Is <code>cond1</code> false? (e.g., flip results of logic tests)</td>
<td align="left"><code>1 != 1</code></td>
<td align="left">FALSE</td>
</tr>
<tr class="even">
<td align="left"><code>any</code></td>
<td align="left"><code>any(cond1, cond2, cond3, ...)</code></td>
<td align="left">Are any of the <code>conditions</code> true?</td>
<td align="left"><code>any(1 == 1, 1 == 2, 1 == 3)</code></td>
<td align="left">TRUE</td>
</tr>
<tr class="odd">
<td align="left"><code>all</code></td>
<td align="left"><code>all(cond1, cond2, cond3, ...)</code></td>
<td align="left">Are all of the <code>conditions</code> true?</td>
<td align="left"><code>all(1 == 1, 1 == 2, 1 == 3)</code></td>
<td align="left">FALSE</td>
</tr>
<tr class="even">
<td align="left"><code>xor</code></td>
<td align="left"><code>xor(cond1, cond2)</code></td>
<td align="left">Is exactly <strong>one</strong> of <code>cond1</code> and <code>cond2</code> true?</td>
<td align="left">`xor(1 == 1, 1 == 2)’</td>
<td align="left">TRUE</td>
</tr>
</tbody>
</table>
<p>To use a Boolean operator, place it between two <strong>complete</strong> logical tests. R will execute each logical test and then use the Boolean operator to combine the results into a single <code>TRUE</code> or <code>FALSE</code>. Here are a few contrived examples of how boolean operators work.</p>
<pre class="r"><code># Is 4 &gt; 3 &amp; 4 &lt; 6?
4 &gt; 3 &amp; 4 &lt; 6</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code># Is the addition of 1 to 2 greater than 2 or greater than 4?
1 + 2 &gt; 2 | 1 + 2 &gt; 4</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code># Is &quot;a&quot; equal to &quot;a&quot; but not equal to &quot;b&quot;
&quot;a&quot; == &quot;a&quot; &amp; &quot;a&quot; != &quot;b&quot;</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code># Are any of these conditions true: is 5 greater than or equal to 6, is 1 equal to 2, and is 1 / 2 less than or equal to 2 / 5?
any(5 &gt;= 6, 1 == 2, 1/2 &lt;= 2/5)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>Notice each operation <strong>always</strong> return one <code>TRUE</code> or <code>FALSE</code>, meaning you can string together as many logical tests as you wish using multiple boolean operators.</p>
<pre class="r"><code>1 &lt; 2 &amp; 2 &lt; 3 &amp; 3 &lt; 4</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>When used with vectors, Boolean operators will follow the same element-wise execution as arithmetic and logical operators.</p>
<pre class="r"><code>a &lt;- c(1, 2, 3)
b &lt;- c(1, 2, 3)
c &lt;- c(1, 2, 4)

a == b</code></pre>
<pre><code>## [1] TRUE TRUE TRUE</code></pre>
<pre class="r"><code>b == c</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE</code></pre>
<pre class="r"><code>a == b &amp; b == c</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE</code></pre>
<p>Just like using a single logical test to index a vector, we can easily extract cases from data which meet two or more logical tests. For instance, cars which are are 4-wheel drive and low in price, small but have high horsepower, or have good gas mileage but are not made by Buick. Let’s look at a few examples using our smaller <code>sm_cars</code> dataset.</p>
<pre class="r"><code># Which cars have both low prices and high milage per gallon
sm_cars$Model[sm_cars$Max.Price &lt; 20 &amp; sm_cars$MPG.city &gt; 20]</code></pre>
<pre><code>## [1] Integra Century
## 93 Levels: 100 190E 240 300E 323 535i 626 850 90 900 Accord ... Vision</code></pre>
<pre class="r"><code># Which cars have front wheel drive or a larger engine (&gt; 3)
sm_cars$Model[sm_cars$DriveTrain == &quot;Front&quot; | sm_cars$EngineSize &gt; 3]</code></pre>
<pre><code>##  [1] Integra    Legend     90         100        535i       Century   
##  [7] LeSabre    Roadmaster Riviera    DeVille   
## 93 Levels: 100 190E 240 300E 323 535i 626 850 90 900 Accord ... Vision</code></pre>
<pre class="r"><code># Which cars are large but not made by Buick
sm_cars$Model[sm_cars$Type == &quot;Large&quot; &amp; sm_cars$Manufacturer != &quot;Buick&quot;]</code></pre>
<pre><code>## [1] DeVille
## 93 Levels: 100 190E 240 300E 323 535i 626 850 90 900 Accord ... Vision</code></pre>
<p>As noted above, you can also combine as many logical vectors as you want to create increasingly complex selection criteria. For example, the following logical vector returns TRUE for cases where car sizes are midsized OR large, AND where the max price is less than 20k.</p>
<pre class="r"><code>sm_cars[(sm_cars$Type == &quot;Midsize&quot; | sm_cars$Type == &quot;Large&quot;) &amp; sm_cars$Max.Price &lt; 20, ]</code></pre>
<pre><code>##   Manufacturer   Model    Type Max.Price MPG.city     AirBags DriveTrain
## 6        Buick Century Midsize      17.3       22 Driver only      Front
##   EngineSize
## 6        2.2</code></pre>
</div>
<div id="missing-values" class="section level2">
<h2>Missing Values</h2>
<table>
<colgroup>
<col width="22%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Description</th>
<th align="left">Example</th>
<th align="left">Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>na.rm()</code></td>
<td align="left">R function logical argument to ignore <code>NA</code></td>
<td align="left"><code>mean(c(1,2,NA), na.rm = T)</code></td>
<td align="left">1.5</td>
</tr>
<tr class="even">
<td align="left"><code>is.na()</code></td>
<td align="left">Logical test of whether a vector element is <code>NA</code></td>
<td align="left"><code>is.na(c(1, NA, 2)</code></td>
<td align="left">FALSE, TRUE, FALSE</td>
</tr>
<tr class="odd">
<td align="left"><code>complete.cases()</code></td>
<td align="left">More flexible than <code>is.na</code>. Can operate on data frames rows.</td>
<td align="left"><code>complete.cases(data.frame(a = 1:2, b = c(3, NA)))</code></td>
<td align="left">TRUE, FALSE</td>
</tr>
<tr class="even">
<td align="left"><code>which()</code></td>
<td align="left">Provides indices for <code>TRUE</code> values</td>
<td align="left"><code>which(c(T, F, T))</code></td>
<td align="left">1, 3</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>Missing values are a common occurence in nearly all studies. R represents missing terms with <code>NA</code> which stands for “not available”. R will treat <code>NA</code> exactly as you should want missing information treated. For example, what result would expect if you added 1 to a piece of missing information?</p>
<pre class="r"><code>NA + 1</code></pre>
<pre><code>## [1] NA</code></pre>
<p>R returns another <code>NA</code>. It would not be correct to return 1, because there is a good chance the piece of missing information is not zero. In other words, R does not have enough information to determine the result. What if you tested whether a missing value is equal to 1?</p>
<pre class="r"><code>NA == 1</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Same issue. R does not know if the <code>NA</code> is equal to 1 because <code>NA</code> is an unknowable quantity. Generally, <code>NA</code>s tend to propogate whenever included in an R operation or function, leading to much confusion when one starts working with R. Suppose you collected data from 5 people and one of the values is missing. If you try to take an average of these values with the <code>mean</code> function, your result will be <code>NA</code> as follows.</p>
<pre class="r"><code>a &lt;- c(1, 5, NA, 2, 10)
mean(a)</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Thankfully, there is a workaround for this. Most R functions come with an optional argument, <code>na.rm</code>, which stands for <code>NA</code> remove (note other functions may have different arguments for handling <code>NA</code>, such as the <code>cor</code> function). If set to <code>TRUE</code>, the argument tells the function to ignore <code>NA</code> values. Let’s try calculating the <code>mean</code> of the vector <code>a</code> again, this time with the additional <code>na.rm = TRUE</code> argument.</p>
<pre class="r"><code>mean(a, na.rm = TRUE)</code></pre>
<pre><code>## [1] 4.5</code></pre>
<p>Sometimes you wish to probe deeper into the missing data cases themselves. You might think you could extrapolate these vlues with a logical test, but think again. If something is a missing value, any logical test that uses it will return a missing value.</p>
<pre class="r"><code>NA == NA</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Don’t worry, R has several option for helping you find missing values. The first is to identify which rows are missing by combining <code>which</code> and <code>is.na()</code>. <code>which</code> is a handy function for finding where the values in a vector satisfy some criteria. For example, we may which to know the actual row locations of all aces in our <code>deck</code> example.</p>
<pre class="r"><code>which(deck$face == &quot;ace&quot;)</code></pre>
<pre><code>## [1]  1 14 27 40</code></pre>
<p>This tells us the 1, 14, 27, and 40th row (every 13th card) contain the ace. <code>is.na</code> tests whether any vector values equal <code>NA</code> and returns a logical vector.</p>
<pre class="r"><code>vec &lt;- c(1, 2, 3, NA)
is.na(vec)</code></pre>
<pre><code>## [1] FALSE FALSE FALSE  TRUE</code></pre>
<p>Since <code>is.na()</code> provides us a logical vector, we can combine it with <code>which()</code> to find out where the missing values are located. For instance, we may want to know which animals are missing REM sleep times in the <code>msleep</code> dataset.</p>
<pre class="r"><code>which(is.na(msleep$sleep_rem))  # For which rows in msleep are animals missing data; i.e., is.na is TRUE</code></pre>
<pre><code>##  [1]  1  8 10 21 27 36 41 44 45 47 51 52 53 56 57 60 65 70 75 76 80 82</code></pre>
<p>This returns a vector of row indexes which we can throw directly into a subset, perhaps only pulling out the <code>names</code> to see which animals are missing data.</p>
<pre class="r"><code>msleep[which(is.na(msleep$sleep_rem)), &quot;name&quot;]</code></pre>
<pre><code>## # A tibble: 22 x 1
##    name                      
##    &lt;chr&gt;                     
##  1 Cheetah                   
##  2 Vesper mouse              
##  3 Roe deer                  
##  4 Asian elephant            
##  5 Western american chipmunk 
##  6 African elephant          
##  7 &quot;Vole &quot;                   
##  8 Round-tailed muskrat      
##  9 Slow loris                
## 10 Northern grasshopper mouse
## # ... with 12 more rows</code></pre>
<p><code>complete.cases</code> is just like <code>is.na</code>, but can also tell you if an entire row of data has any missing values. Researchers sometimes use <code>complete.cases</code> to return a data frame where every row has complete data. However, be cautious as it can lead to massive data loss, especially in large or complex datasets. Such situations may require more sophisticated missing data analyses and imputation in such cases.</p>
<pre class="r"><code>head(msleep)</code></pre>
<pre><code>## # A tibble: 6 x 11
##   name  genus vore  order conservation sleep_total sleep_rem sleep_cycle
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
## 1 Chee~ Acin~ carni Carn~ lc                  12.1      NA        NA    
## 2 Owl ~ Aotus omni  Prim~ &lt;NA&gt;                17         1.8      NA    
## 3 Moun~ Aplo~ herbi Rode~ nt                  14.4       2.4      NA    
## 4 Grea~ Blar~ omni  Sori~ lc                  14.9       2.3       0.133
## 5 Cow   Bos   herbi Arti~ domesticated         4         0.7       0.667
## 6 Thre~ Brad~ herbi Pilo~ &lt;NA&gt;                14.4       2.2       0.767
## # ... with 3 more variables: awake &lt;dbl&gt;, brainwt &lt;dbl&gt;, bodywt &lt;dbl&gt;</code></pre>
<pre class="r"><code>good &lt;- complete.cases(msleep)
msleep[good,]                    # Notice this results in a loss of 63 data points (75% of rows have at least one missing data point)</code></pre>
<pre><code>## # A tibble: 20 x 11
##    name  genus vore  order conservation sleep_total sleep_rem sleep_cycle
##    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
##  1 Grea~ Blar~ omni  Sori~ lc                  14.9       2.3       0.133
##  2 Cow   Bos   herbi Arti~ domesticated         4         0.7       0.667
##  3 Dog   Canis carni Carn~ domesticated        10.1       2.9       0.333
##  4 Guin~ Cavis herbi Rode~ domesticated         9.4       0.8       0.217
##  5 Chin~ Chin~ herbi Rode~ domesticated        12.5       1.5       0.117
##  6 Less~ Cryp~ omni  Sori~ lc                   9.1       1.4       0.15 
##  7 Long~ Dasy~ carni Cing~ lc                  17.4       3.1       0.383
##  8 Nort~ Dide~ omni  Dide~ lc                  18         4.9       0.333
##  9 Big ~ Epte~ inse~ Chir~ lc                  19.7       3.9       0.117
## 10 Horse Equus herbi Peri~ domesticated         2.9       0.6       1    
## 11 Euro~ Erin~ omni  Erin~ lc                  10.1       3.5       0.283
## 12 Dome~ Felis carni Carn~ domesticated        12.5       3.2       0.417
## 13 Gold~ Meso~ herbi Rode~ en                  14.3       3.1       0.2  
## 14 Hous~ Mus   herbi Rode~ nt                  12.5       1.4       0.183
## 15 Rabb~ Oryc~ herbi Lago~ domesticated         8.4       0.9       0.417
## 16 Labo~ Ratt~ herbi Rode~ lc                  13         2.4       0.183
## 17 East~ Scal~ inse~ Sori~ lc                   8.4       2.1       0.167
## 18 Thir~ Sper~ herbi Rode~ lc                  13.8       3.4       0.217
## 19 Pig   Sus   omni  Arti~ domesticated         9.1       2.4       0.5  
## 20 Braz~ Tapi~ herbi Peri~ vu                   4.4       1         0.9  
## # ... with 3 more variables: awake &lt;dbl&gt;, brainwt &lt;dbl&gt;, bodywt &lt;dbl&gt;</code></pre>
<div id="exercise---logical-subsetting-and-missing-values" class="section level4">
<h4>Exercise - Logical Subsetting and Missing Values</h4>
<ol style="list-style-type: decimal">
<li>Retain only the animals who sleep longer than they are awake.</li>
<li>Retain only animals who are carnivores and sleep more than 12 hours a day.</li>
<li>PUll out just the <code>names</code> of the animals who sleep the heaviest, either in terms of longest rem (more than 3 hours) or number of hours (more than 14). Bonus: subset in a way which does not return <code>NA</code> values.</li>
<li>Eliminate any animal with <strong>missing</strong> sleep_cycle data.</li>
</ol>
<pre class="r"><code># Solution 1
msleep[msleep$sleep_total &gt; msleep$awake, ]</code></pre>
<pre><code>## # A tibble: 31 x 11
##    name  genus vore  order conservation sleep_total sleep_rem sleep_cycle
##    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
##  1 Chee~ Acin~ carni Carn~ lc                  12.1      NA        NA    
##  2 Owl ~ Aotus omni  Prim~ &lt;NA&gt;                17         1.8      NA    
##  3 Moun~ Aplo~ herbi Rode~ nt                  14.4       2.4      NA    
##  4 Grea~ Blar~ omni  Sori~ lc                  14.9       2.3       0.133
##  5 Thre~ Brad~ herbi Pilo~ &lt;NA&gt;                14.4       2.2       0.767
##  6 Chin~ Chin~ herbi Rode~ domesticated        12.5       1.5       0.117
##  7 Long~ Dasy~ carni Cing~ lc                  17.4       3.1       0.383
##  8 Nort~ Dide~ omni  Dide~ lc                  18         4.9       0.333
##  9 Big ~ Epte~ inse~ Chir~ lc                  19.7       3.9       0.117
## 10 West~ Euta~ herbi Rode~ &lt;NA&gt;                14.9      NA        NA    
## # ... with 21 more rows, and 3 more variables: awake &lt;dbl&gt;, brainwt &lt;dbl&gt;,
## #   bodywt &lt;dbl&gt;</code></pre>
<pre class="r"><code># Solution 2
msleep[msleep$vore == &quot;carni&quot; &amp; msleep$sleep_total &gt; 12, ]</code></pre>
<pre><code>## # A tibble: 10 x 11
##    name  genus vore  order conservation sleep_total sleep_rem sleep_cycle
##    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
##  1 Chee~ Acin~ carni Carn~ lc                  12.1      NA        NA    
##  2 Long~ Dasy~ carni Cing~ lc                  17.4       3.1       0.383
##  3 Dome~ Felis carni Carn~ domesticated        12.5       3.2       0.417
##  4 Thic~ Lutr~ carni Dide~ lc                  19.4       6.6      NA    
##  5 Nort~ Onyc~ carni Rode~ lc                  14.5      NA        NA    
##  6 Tiger Pant~ carni Carn~ en                  15.8      NA        NA    
##  7 Lion  Pant~ carni Carn~ vu                  13.5      NA        NA    
##  8 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;                NA        NA        NA    
##  9 &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;                NA        NA        NA    
## 10 Arct~ Vulp~ carni Carn~ &lt;NA&gt;                12.5      NA        NA    
## # ... with 3 more variables: awake &lt;dbl&gt;, brainwt &lt;dbl&gt;, bodywt &lt;dbl&gt;</code></pre>
<pre class="r"><code># Solution 3
msleep[msleep$sleep_rem &gt; 3 | msleep$sleep_total &gt; 14, &quot;name&quot;]</code></pre>
<pre><code>## # A tibble: 39 x 1
##    name                      
##    &lt;chr&gt;                     
##  1 &lt;NA&gt;                      
##  2 Owl monkey                
##  3 Mountain beaver           
##  4 Greater short-tailed shrew
##  5 Three-toed sloth          
##  6 &lt;NA&gt;                      
##  7 &lt;NA&gt;                      
##  8 Long-nosed armadillo      
##  9 North American Opossum    
## 10 &lt;NA&gt;                      
## # ... with 29 more rows</code></pre>
<pre class="r"><code># Bonus
msleep[which(msleep$sleep_rem &gt; 3 | msleep$sleep_total &gt; 14), &quot;name&quot;]  # wrap condition in which test which returns only row number matching condition</code></pre>
<pre><code>## # A tibble: 23 x 1
##    name                      
##    &lt;chr&gt;                     
##  1 Owl monkey                
##  2 Mountain beaver           
##  3 Greater short-tailed shrew
##  4 Three-toed sloth          
##  5 Long-nosed armadillo      
##  6 North American Opossum    
##  7 Big brown bat             
##  8 European hedgehog         
##  9 Western american chipmunk 
## 10 Domestic cat              
## # ... with 13 more rows</code></pre>
<pre class="r"><code># Solution 4
msleep[!is.na(msleep$sleep_cycle), ]</code></pre>
<pre><code>## # A tibble: 32 x 11
##    name  genus vore  order conservation sleep_total sleep_rem sleep_cycle
##    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
##  1 Grea~ Blar~ omni  Sori~ lc                  14.9       2.3       0.133
##  2 Cow   Bos   herbi Arti~ domesticated         4         0.7       0.667
##  3 Thre~ Brad~ herbi Pilo~ &lt;NA&gt;                14.4       2.2       0.767
##  4 Nort~ Call~ carni Carn~ vu                   8.7       1.4       0.383
##  5 Dog   Canis carni Carn~ domesticated        10.1       2.9       0.333
##  6 Guin~ Cavis herbi Rode~ domesticated         9.4       0.8       0.217
##  7 Chin~ Chin~ herbi Rode~ domesticated        12.5       1.5       0.117
##  8 Less~ Cryp~ omni  Sori~ lc                   9.1       1.4       0.15 
##  9 Long~ Dasy~ carni Cing~ lc                  17.4       3.1       0.383
## 10 Nort~ Dide~ omni  Dide~ lc                  18         4.9       0.333
## # ... with 22 more rows, and 3 more variables: awake &lt;dbl&gt;, brainwt &lt;dbl&gt;,
## #   bodywt &lt;dbl&gt;</code></pre>
<pre class="r"><code># Solution 5
msleep$sleep_rem[is.na(msleep$sleep_rem)] &lt;- mean(msleep$sleep_rem, na.rm = T)</code></pre>
</div>
<div id="summary-1" class="section level3">
<h3>Summary</h3>
<p>You have learned how to access values stored in R. You can retrieve a copy of values living inside a data frame and use the copies for new computations. To use it, write the name of an object followed by brackets and indexes. If your object is one-dimensional, like a vector, you only need to supply one index. If it is two-dimensional, like a data frame, you need to supply two indexes separated by a comma. And, if it is n-dimensional, you need to supply n indexes, each separated by a comma. Through the use of logical subsetting, you can carry out many advanced operations to slice and dice your data as needed such as locating groups, errors, and missing values in your dataset.</p>
</div>
</div>
</div>
<div id="analyzing-and-modifying-values" class="section level1">
<h1>Analyzing and Modifying Values</h1>
<p>You are now a pro at accessing elements from a data frame. However, looking at raw data is not enough. Often, we want to run <strong>analyses</strong> over subsets of data or directly <strong>modify</strong> values themselves. For instance, we may wish to drop outliers or compare a variable mean between males and females. In this section, we’ll cover many core R functions for calculating summary statistics and combine these with indexing to carry out summary operations on groups of data.</p>
<div id="modifying-data" class="section level2">
<h2>Modifying Data</h2>
<p>Sometimes we need to change certain elements within our dataset. For instance, the point system of the cards in our <code>deck</code> object may change according to the rules of different games. For example, in war and poker, aces are usually score higher thank kings. They’d have a point value of 14, not 1. We will experiment with altering values to match different games. Before we begin, make a copy of your <code>deck</code> which you can manipulate. This will ensure you always have an original <code>deck</code> copy to fall back on.</p>
<pre class="r"><code>deck2 &lt;- deck</code></pre>
<div id="changing-values-in-place" class="section level3">
<h3>Changing Values in Place</h3>
<p>You can use R’s notation system to modify values within an R object. First, describe the value (or values) you wish to modify. Then use the assignment operator <code>&lt;-</code> to overwrite those values. R will update the selected values <em>in the original object</em>. For example.</p>
<pre class="r"><code># Create a vector of zeros
vec &lt;- c(0, 0, 0, 0)
vec</code></pre>
<pre><code>## [1] 0 0 0 0</code></pre>
<pre class="r"><code># Select first value of vec
vec[1]</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code># Modify by assigning this element a new value
vec[1] &lt;- 1000
vec</code></pre>
<pre><code>## [1] 1000    0    0    0</code></pre>
<p>You can also replace multiple values at once as long as the number of new values equals the number of selected values.</p>
<pre class="r"><code>vec[c(1,3)] &lt;- c(1, 1)
vec</code></pre>
<pre><code>## [1] 1 0 1 0</code></pre>
<p>Of course you can also change values of a vector using a logical indexing vector. For example, let’s say you have a vector of numbers that should be from 1 to 10. If values are outside of this range, you want to set them to either the minimum (1) or maximum (10) value:</p>
<pre class="r"><code># x is a vector of numbers that should be from 1 to 10
x &lt;- c(5, -5, 7, 4, 11, 5, -2)

# Assign values less than 1 to 1
x[x &lt; 1] &lt;- 1

# Assign values greater than 10 to 10
x[x &gt; 10] &lt;- 10

# Print the result!
x</code></pre>
<pre><code>## [1]  5  1  7  4 10  5  1</code></pre>
<p>As you can see, our new values of x are now never less than 1 or greater than 10! In a similiar vein, we could create a logical index which checks for <em>invalid</em> responses and swaps them with <code>NA</code>. This might occur in SPSS where missing is stored as <code>999</code> or other software that sometimes stores missing as <code>.</code>. To do so, we need to come up with a vector of <em>valid</em> responses and create a logical statement to find every instance of a vector that is <em>NOT</em> equal to each of the valid responses. Let’s look at an example for a hypothetical survey on happiness.</p>
<pre class="r"><code># survey responses with two invalid values, -2 and 999
happy &lt;- c(1, 4, 2, 999, 2, 3, -2, 3, 2, 999)</code></pre>
<p>In the <code>happy</code> vector, only the responses 1 to 5 are valid. To identify which responses are <em>invalid</em> we will use the <code>%in%</code> operator which will test each survey response against every possible valid number. Because we want to find the <em>invalid</em> responses, we’ll add the == <code>FALSE</code> condition (equivalent, != <code>TRUE</code>). Then use this index to replace invalid cases with <code>NA</code></p>
<pre class="r"><code>invalid &lt;- (happy %in% 1:5) == FALSE
happy[invalid]</code></pre>
<pre><code>## [1] 999  -2 999</code></pre>
<pre class="r"><code>happy[invalid] &lt;- NA
happy</code></pre>
<pre><code>##  [1]  1  4  2 NA  2  3 NA  3  2 NA</code></pre>
<p>If desired, you could combine all of the above commands into a single line.</p>
<pre class="r"><code>happy[(happy %in% 1:5) == FALSE] &lt;- NA</code></pre>
<p>Now we can carry out various operations, such as calculating the <code>mean()</code> of the vector for valid responses.</p>
<pre class="r"><code>mean(happy, na.rm = T)</code></pre>
<pre><code>## [1] 2.428571</code></pre>
</div>
<div id="augmenting-objects" class="section level3">
<h3>Augmenting Objects</h3>
<p>It is also very easy to create values in your objects that do not yet exist.</p>
<p>You can add new columns to a dataframe using the <code>$</code> and <code>&lt;-</code> operators together. To do this, just use the <code>df$name</code> notation and assign it a new vector of data. For example, let’s create a data frame called <code>survey</code> with two columns: <code>index</code> and <code>age</code>.</p>
<pre class="r"><code># Create a new dataframe called survey

survey &lt;- data.frame(index = c(1, 2, 3, 4, 5),
                     age = c(24, 25, 42, 56, 22))
survey</code></pre>
<pre><code>##   index age
## 1     1  24
## 2     2  25
## 3     3  42
## 4     4  56
## 5     5  22</code></pre>
<p>Now, let’s add a new column called <code>sex</code> with a vector of sex data.</p>
<pre class="r"><code>survey$sex &lt;- c(&quot;m&quot;, &quot;m&quot;, &quot;f&quot;, &quot;f&quot;, &quot;m&quot;)</code></pre>
<p>Here’s the result. As you can see, <code>survey</code> has a new column with the name <code>sex</code> with the values we specified.</p>
<pre class="r"><code>survey</code></pre>
<pre><code>##   index age sex
## 1     1  24   m
## 2     2  25   m
## 3     3  42   f
## 4     4  56   f
## 5     5  22   m</code></pre>
<p>If you wish to add something like an <code>id</code> variable ranging from 1 to the <code>nrow()</code> in the full dataset, where <code>nrow()</code> gives you the total number of rows or participants. In our <code>deck</code> example, <code>nrow(deck)</code> gives 52.</p>
<pre class="r"><code>deck2$id &lt;- 1:nrow(deck)   # Add id for each card ranging from 1 to total number of rows
length(deck2$id)           # Verify new vector contains 52 id variables</code></pre>
<pre><code>## [1] 52</code></pre>
<p>You can also easily remove any columns from a data frame (and elements from a list) by assigning them to <code>NULL</code>.</p>
<pre class="r"><code>deck2$id &lt;- NULL
head(deck2)</code></pre>
<pre><code>##    face   suit value
## 1   ace hearts     1
## 2   two hearts     2
## 3 three hearts     3
## 4  four hearts     4
## 5  five hearts     5
## 6   six hearts     6</code></pre>
</div>
<div id="changing-column-names" class="section level3">
<h3>Changing Column Names</h3>
<p>Recall the <code>names</code> function pulls out a vector of characters corresponding to column names. For instance, the names of <code>survey</code> are index, age, sex. We can use this in combination with indexing and reassignment to alter column names within our dataset.</p>
<p>For example, let’s change the name of the first column of <code>survey</code> from <code>index</code> to <code>participantid</code>.</p>
<pre class="r"><code># Change the name of the first column of survey to &quot;participantid&quot;
names(survey)[1] &lt;- &quot;participantid&quot;
survey</code></pre>
<pre><code>##   participantid age sex
## 1             1  24   m
## 2             2  25   m
## 3             3  42   f
## 4             4  56   f
## 5             5  22   m</code></pre>
<p>There is a <strong>major problem</strong> with the above method - you are manually entering numbers to alter columns. In reality, you may have a very large data set and not immediately know the numerical index of all columns. Moreoever, the data ordering may have changed, a column may have been deleted, or some alteration may have altered the <code>dim</code> of your data frame.</p>
<p>To avoid such issues, it’s better to change column names using a logical vector of the format <code>names(df)[names(df) == "old.name"] &lt;- "new.name"</code>. Here’s how to read this: “Change the names of <code>df</code> to <code>new.name</code>, but only where the original name is equal to <code>old.name</code>”. Let’s use logical indexing to change the name of the column <code>survey$age</code> to <code>survey$years</code>.</p>
<pre class="r"><code># Change the column name from age to years
names(survey)[names(survey) == &quot;age&quot;] &lt;- &quot;years&quot;

survey</code></pre>
<pre><code>##   participantid years sex
## 1             1    24   m
## 2             2    25   m
## 3             3    42   f
## 4             4    56   f
## 5             5    22   m</code></pre>
<div id="exercise---modifying-values" class="section level4">
<h4>Exercise - Modifying Values</h4>
<ol style="list-style-type: decimal">
<li>Say we are playing the game of hearts where all heart cards are worth 1 point and the queen of spades is worth 13 points. Using logic, do the following:</li>
</ol>
<ul>
<li>In <code>deck2</code>, update all “heart” cards to a value of 1</li>
<li>For just the queen of spades, update the value to 13</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li></li>
<li>Replace all <code>NA</code> values in <code>msleep$sleep_rem</code> with the mean of <code>msleep$sleep_rem</code>.</li>
<li>Change the name of <code>deck2</code> values column to points.</li>
</ol>
</div>
</div>
</div>
<div id="common-vector-functions" class="section level2">
<h2>Common Vector Functions</h2>
<div id="arithmetic" class="section level3">
<h3>Arithmetic</h3>
</div>
<div id="counting" class="section level3">
<h3>Counting</h3>
<table>
<colgroup>
<col width="22%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Description</th>
<th align="left">Example</th>
<th align="left">Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>unique(x)</code></td>
<td align="left">Returns a vector of all unique values</td>
<td align="left"><code>unique(c(1, 1, 2, 2, 3)</code></td>
<td align="left">1, 2, 3</td>
</tr>
<tr class="even">
<td align="left"><code>table(x, exclude)</code></td>
<td align="left">Returns table (contigency if x &gt; 1) of all unique values and their counts. <code>exclude = NULL</code> counts NA values.</td>
<td align="left"><code>table(c("a", "a", "b"))</code></td>
<td align="left">2 - “a”, 1 - “b”</td>
</tr>
<tr class="odd">
<td align="left"><code>prop.table(x, margin)</code></td>
<td align="left">Divide <code>x</code> by sum of all cells or sum of rows/columns.</td>
<td align="left"><code>prop.table(c(1, 1, 1))</code></td>
<td align="left">.33, .33, .33</td>
</tr>
<tr class="even">
<td align="left"><code>chisq.test(x, y)</code></td>
<td align="left">Perform chi-square test on two numeric vectors</td>
<td align="left"><code>chisq.test(rep(1:2, e = 10), rep(2:1, e = 10))</code></td>
<td align="left"><span class="math inline">\(\chi^2\)</span> = 16.2</td>
</tr>
<tr class="odd">
<td align="left"><code>ftable(x...)</code></td>
<td align="left">Take numerous categorical data vectors and create a flat contingency table</td>
<td align="left">(see example below)</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>Next, we’ll move on to common counting functions and contigency analyses for vectors with discrete or non-numeric data. Discrete data are those like gender, occupation, and sleep stage, that only allow for a finite (or at least, plausibly finite) set of responses. While they can be used with numeric, this is often impractical. Most functions can take numeric or character as arguments.</p>
<p>The function <code>unique(x)</code> will tell you all the unique values in the vector, but not anything about how frequently they occur. This can be helpful for identifying all possible values a variable takes on within your data frame. For instance, we may wish to know all possible time points at which Chickens were weighed in the <code>ChickWeight</code> data frame. In combination with <code>length</code>, you can identify variables with few values which can be transformed into factors.</p>
<pre class="r"><code>unique(ChickWeight$Time)</code></pre>
<pre><code>##  [1]  0  2  4  6  8 10 12 14 16 18 20 21</code></pre>
<pre class="r"><code>length(unique(ChickWeight$Time))</code></pre>
<pre><code>## [1] 12</code></pre>
<p>Twelve seems like a lot. Keep it as numeric for now. You can also use <code>unique(x)</code> on a dataframe to return only unique rows. If you suspect some participant data was accidentally entered twice, this will help eliminate it.</p>
<pre class="r"><code># create example dataframe with a duplicate row
dat &lt;- data.frame(letter = c(rep(&quot;A&quot;, 3), &quot;B&quot;),
         number = rep(1, 4))
dat</code></pre>
<pre><code>##   letter number
## 1      A      1
## 2      A      1
## 3      A      1
## 4      B      1</code></pre>
<pre class="r"><code>unique(dat)</code></pre>
<pre><code>##   letter number
## 1      A      1
## 4      B      1</code></pre>
<p>The function <code>table()</code> does the same thing as <code>unique</code>, but goes a step further in telling you how often each of the unique values occur.</p>
<pre class="r"><code>table(ChickWeight$Time)</code></pre>
<pre><code>## 
##  0  2  4  6  8 10 12 14 16 18 20 21 
## 50 50 49 49 49 49 49 48 47 47 46 45</code></pre>
<p>We can see some drop out for Chickens across the study, with the initial n = 50 but shrinking to 45. This function is often useful to get frequency counts. For instance, let’s look at how many types of cars are in the <code>Car93</code> data set.</p>
<pre class="r"><code>table(Cars93$Type)</code></pre>
<pre><code>## 
## Compact   Large Midsize   Small  Sporty     Van 
##      16      11      22      21      14       9</code></pre>
<p>If you want to get a table of percentages instead of counts, you can just divide the result of the <code>table</code> function by the sume of the result. An even quicker way is to apply the <code>prop.table</code> function to convert numbers into fractions.</p>
<pre class="r"><code># Two ways to get a table of percentages
table(Cars93$Type) / sum(table(Cars93$Type))      </code></pre>
<pre><code>## 
##    Compact      Large    Midsize      Small     Sporty        Van 
## 0.17204301 0.11827957 0.23655914 0.22580645 0.15053763 0.09677419</code></pre>
<pre class="r"><code>prop.table(table(Cars93$Type))                          </code></pre>
<pre><code>## 
##    Compact      Large    Midsize      Small     Sporty        Van 
## 0.17204301 0.11827957 0.23655914 0.22580645 0.15053763 0.09677419</code></pre>
<p>Great! We can see our dataset contains mostly middle to small vehicles. Is this true everywhere? Perhaps you would like to make a <strong>contigency table</strong> display these counts broken down by another category, such as the <code>origin</code> of the car? Let’s make a table comparing the counts across US and non-US locations.</p>
<pre class="r"><code>table(Cars93$Type, Cars93$Origin)</code></pre>
<pre><code>##          
##           USA non-USA
##   Compact   7       9
##   Large    11       0
##   Midsize  10      12
##   Small     7      14
##   Sporty    8       6
##   Van       5       4</code></pre>
<p>In terms of raw counts, we definitley see Americans love their trucks and escalades! This table shows the joint distribution of two categorical values, also known as <strong>contigency tables</strong>. We can easily conver this into percentage with the <code>prop.table</code> function and multiplying the results by 100.</p>
<pre class="r"><code>prop.table(table(Cars93$Type, Cars93$Origin))         #frequencies as fractions</code></pre>
<pre><code>##          
##                  USA    non-USA
##   Compact 0.07526882 0.09677419
##   Large   0.11827957 0.00000000
##   Midsize 0.10752688 0.12903226
##   Small   0.07526882 0.15053763
##   Sporty  0.08602151 0.06451613
##   Van     0.05376344 0.04301075</code></pre>
<pre class="r"><code>prop.table(table(Cars93$Type, Cars93$Origin)) * 100   #Convert to % </code></pre>
<pre><code>##          
##                 USA   non-USA
##   Compact  7.526882  9.677419
##   Large   11.827957  0.000000
##   Midsize 10.752688 12.903226
##   Small    7.526882 15.053763
##   Sporty   8.602151  6.451613
##   Van      5.376344  4.301075</code></pre>
<p>This gives us the joint probability distribution; i.e., about 7.5% of cars, on average, are likely to be small and American origin. However, say we are interested in the distribution of one variable compared to the distribution of the other? Rather than do it <strong>jointly</strong>, we can do it by row or column using the <code>margin</code> argument in <code>prop.table</code>. Let’s compare the distribution of car types among the US and (separately) non-US cars.</p>
<pre class="r"><code>prop.table(table(Cars93$Type, Cars93$Origin), margin = 2) * 100</code></pre>
<pre><code>##          
##                 USA   non-USA
##   Compact 14.583333 20.000000
##   Large   22.916667  0.000000
##   Midsize 20.833333 26.666667
##   Small   14.583333 31.111111
##   Sporty  16.666667 13.333333
##   Van     10.416667  8.888889</code></pre>
<p>Here we can see that small cars are twice as frequency in non-USA compared to the USA part of the dataset. To clarify what is happening, notice the percentages add up to 100 in the columns as opposed to 100 for the whole table (which is what we calculated above).</p>
<p>A common question which arises with contigency tbles is if the row and column variables are independent. In this case, is car type independent of its origin? The most basic way to answer this is to run a chi-squared test with the <code>chisq.test()</code> function.</p>
<pre class="r"><code>chisq.test(Cars93$Type, Cars93$Origin)</code></pre>
<pre><code>## Warning in chisq.test(Cars93$Type, Cars93$Origin): Chi-squared
## approximation may be incorrect</code></pre>
<pre><code>## 
##  Pearson&#39;s Chi-squared test
## 
## data:  Cars93$Type and Cars93$Origin
## X-squared = 14.08, df = 5, p-value = 0.01511</code></pre>
<p>We can see a significant association between the two categories. The warning signals our n may be small with certain cells unpopulated. This warning is saying one of our expected cell counts is lower than 5, so the test results should be taken with caution.</p>
<p>Finally, if we desire a more complicated contigency table, such as 3-dimension or higher, then use the <code>ftable</code> function.</p>
<pre class="r"><code># View car type broken down by both country of origin and whether a manual transmission version is available
ftable(Cars93$Man.trans.avail, Cars93$Origin, Cars93$Type)</code></pre>
<pre><code>##              Compact Large Midsize Small Sporty Van
##                                                    
## No  USA            2    11       9     0      0   4
##     non-USA        0     0       4     0      0   2
## Yes USA            5     0       1     7      8   1
##     non-USA        9     0       8    14      6   2</code></pre>
<div id="exercise---vector-functions" class="section level4">
<h4>Exercise - Vector Functions</h4>
<ol style="list-style-type: decimal">
<li>What is the average amount animals sleep in <code>msleep</code>? How about average amount awake?</li>
<li>Which has more variability: rem sleep or sleep cycle?</li>
<li>Which animal sleeps the least? Which sleeps the most? (use logic and subsetting to figure it out)</li>
<li>Count the number of unique <code>order</code>s of animals are in msleep. Your result should return only <strong>one</strong> number.</li>
<li>Create a 2 x 2 contigency table of <code>vore</code> and <code>conservation</code> status. Is there a significant association? Re-run contigency with <code>NA</code> included - do you notice a missing data pattern?</li>
<li>Use logic and <code>sum</code> to count the total number of “aces” in your <code>deck</code>. What proportion of total cards are <code>aces</code>?</li>
</ol>
<pre class="r"><code># Solution 1

# Solution 2
sd(msleep$sleep_rem, na.rm = T); sd(msleep$sleep_cycle, na.rm = T); </code></pre>
<pre><code>## [1] 1.110554</code></pre>
<pre><code>## [1] 0.3586801</code></pre>
<pre class="r"><code># Solution 3
msleep[which(msleep$sleep_total == min(msleep$sleep_total)), ]  </code></pre>
<pre><code>## # A tibble: 1 x 11
##   name  genus vore  order conservation sleep_total sleep_rem sleep_cycle
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
## 1 Gira~ Gira~ herbi Arti~ cd                   1.9       0.4          NA
## # ... with 3 more variables: awake &lt;dbl&gt;, brainwt &lt;dbl&gt;, bodywt &lt;dbl&gt;</code></pre>
<pre class="r"><code>msleep[which.min(msleep$sleep_total), ]  # shorter solution</code></pre>
<pre><code>## # A tibble: 1 x 11
##   name  genus vore  order conservation sleep_total sleep_rem sleep_cycle
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
## 1 Gira~ Gira~ herbi Arti~ cd                   1.9       0.4          NA
## # ... with 3 more variables: awake &lt;dbl&gt;, brainwt &lt;dbl&gt;, bodywt &lt;dbl&gt;</code></pre>
<pre class="r"><code>msleep[which(msleep$sleep_total == max(msleep$sleep_total)), ]  </code></pre>
<pre><code>## # A tibble: 1 x 11
##   name  genus vore  order conservation sleep_total sleep_rem sleep_cycle
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
## 1 Litt~ Myot~ inse~ Chir~ &lt;NA&gt;                19.9         2         0.2
## # ... with 3 more variables: awake &lt;dbl&gt;, brainwt &lt;dbl&gt;, bodywt &lt;dbl&gt;</code></pre>
<pre class="r"><code>msleep[which.max(msleep$sleep_total), ]  # shorter solution</code></pre>
<pre><code>## # A tibble: 1 x 11
##   name  genus vore  order conservation sleep_total sleep_rem sleep_cycle
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;
## 1 Litt~ Myot~ inse~ Chir~ &lt;NA&gt;                19.9         2         0.2
## # ... with 3 more variables: awake &lt;dbl&gt;, brainwt &lt;dbl&gt;, bodywt &lt;dbl&gt;</code></pre>
<pre class="r"><code># SOlution 4
length(unique(msleep$order))</code></pre>
<pre><code>## [1] 19</code></pre>
<pre class="r"><code># Solution 5
table(msleep$vore, msleep$conservation)</code></pre>
<pre><code>##          
##           cd domesticated en lc nt vu
##   carni    1            2  1  5  1  4
##   herbi    1            7  2 10  3  3
##   insecti  0            0  1  2  0  0
##   omni     0            1  0  8  0  0</code></pre>
<pre class="r"><code>chisq.test(msleep$vore, msleep$conservation)</code></pre>
<pre><code>## Warning in chisq.test(msleep$vore, msleep$conservation): Chi-squared
## approximation may be incorrect</code></pre>
<pre><code>## 
##  Pearson&#39;s Chi-squared test
## 
## data:  msleep$vore and msleep$conservation
## X-squared = 15.751, df = 15, p-value = 0.3988</code></pre>
<pre class="r"><code>table(msleep$vore, msleep$conservation, exclude = NULL)</code></pre>
<pre><code>##          
##           cd domesticated en lc nt vu &lt;NA&gt;
##   carni    1            2  1  5  1  4    5
##   herbi    1            7  2 10  3  3    6
##   insecti  0            0  1  2  0  0    2
##   omni     0            1  0  8  0  0   11
##   &lt;NA&gt;     0            0  0  2  0  0    5</code></pre>
</div>
</div>
<div id="vector-recycling" class="section level3">
<h3>Vector Recycling</h3>
<p>In our virtual <code>die</code> example we subtracted, divided, and multiplied every value by another. For instance, we ran the command <code>die - 1</code> which returned a six-element vector of 0, 1, 2, 3, 4, 5. But what happens if we feed a <code>die</code> more than one number for an operation? Say we try to subtract 1 and 2 by running <code>die - 1:2</code>. Do we get an error? Nope. Instead, R performs <em>vector recycling</em> by subtracting 1 from the first value of <code>die</code>, 2 from the second value, and then repeats this sequence across remaining values to produce 0, 0, 2, 2, 4, 4. If you give R two vectors of unequal length, R repeats the shorter vector until <strong>it is as long as the longer vector</strong>, then does the calculations, and returns the output (see the examples and figure below). If the length of the short vector does not divide evenly into the length of the long vector, R will return a warning message.</p>
<pre class="r"><code>die + 1:2</code></pre>
<pre><code>## [1] 2 4 4 6 6 8</code></pre>
<pre class="r"><code>die * 1:2</code></pre>
<pre><code>## [1]  1  4  3  8  5 12</code></pre>
<pre class="r"><code>c(1,2,4) + c(6,0,9,20,22)</code></pre>
<pre><code>## Warning in c(1, 2, 4) + c(6, 0, 9, 20, 22): longer object length is not a
## multiple of shorter object length</code></pre>
<pre><code>## [1]  7  2 13 21 24</code></pre>
<pre class="r"><code>die + 1:4</code></pre>
<pre><code>## Warning in die + 1:4: longer object length is not a multiple of shorter
## object length</code></pre>
<pre><code>## [1] 2 4 6 8 6 8</code></pre>
<div id="section" class="section level4">
<h4></h4>
</div>
</div>
<div id="exercise---shuffling-cards" class="section level3">
<h3>Exercise - Shuffling Cards</h3>
<ol style="list-style-type: decimal">
<li><p>Say you wanted to randomly select a card from your <code>deck</code> object. <code>deck[1,]</code> will always give you the ace of hearts. Rather, can you provide a function which randomly generates 52 integers to shuffle the deck?</p></li>
<li><p>Now you have a shuffled deck. But, how do you draw from it? If you recall, R is an object-oriented language, meaning the new shuffled deck is, itself, a dataframe which you can further subset. Can you think of a way to add another <code>[]</code> which will draw the first row?</p></li>
</ol>
</div>
<div id="solution-3" class="section level3">
<h3>Solution</h3>
</div>
</div>
</div>
<div id="functions" class="section level1">
<h1>Functions</h1>
<p>As demonstrated earlier with our <code>die</code> example, functions are “canned scripts” that automate more complicated sets of commands, including operations, assignments, and so forth. Whenever you need to do a certain series of steps or analyses numerous times, consider crafting a function to simplify your work. Let’s revisit the shuffling and dealing operations above to see if we can simplify the process.</p>
<p>First, in terms of dealing a card, how can we make a function which always returns the first row of a vector? Complete the following to make such a function.</p>
<pre class="r"><code>deal &lt;- function(cards) {
  # ?
}</code></pre>
<p>While you could use any system that returns the first row of a data frame, I’ll use positive integers and blanks because they seem simplest.</p>
<pre class="r"><code>deal &lt;- function(cards) {
  cards[1, ]
}</code></pre>
<p>Now with this function created, it does exactly what we wanted: deals the top card (i.e., row) from your data set. However, the function isn’t that impressive: if we run <code>deal</code> repeatedly we get the same result.</p>
<pre class="r"><code>deal(deck)</code></pre>
<pre><code>##   face   suit value
## 1  ace hearts     1</code></pre>
<pre class="r"><code>deal(deck)</code></pre>
<pre><code>##   face   suit value
## 1  ace hearts     1</code></pre>
<p>How might we fix this problem by incorporating a <code>shuffle</code> function? We would need to incorporate the <code>sample</code> function inside as well as a <code>cards</code> object to be fed into <code>sample</code>. While there are a few ways to concot this, here is one solution.</p>
<pre class="r"><code>shuffle &lt;- function(cards) {
  random &lt;- sample(1:52, size = 52)
  cards[random, ]
}</code></pre>
<p>Now every time we run <code>deal</code>, we can preface it with <code>shuffle</code> to get a new card on top every single time.</p>
<pre class="r"><code>deal(shuffle(deck))</code></pre>
<pre><code>##    face   suit value
## 43 four spades     4</code></pre>
<pre class="r"><code>deal(shuffle(deck))</code></pre>
<pre><code>##   face   suit value
## 1  ace hearts     1</code></pre>
<p>Let’s break down how we develop and nest functions like <code>deal</code> and <code>shuffle</code> to build bigger programs to do the work for us. We will explore another common example that is readily relatable: temperature conversion.</p>
<center>
<img src="Figures/Temp.jpg" width="250" />
</center>
<p><br></p>
<p>Most of us have an intuitive sense of temperature, with larger numbers indicating more heat (or kinetic energy). At the same time, there are different conventions for representing temperature, including fahrenheit, celsius, and kelvin.</p>
<p>Let’s start by defining a function <code>fahrenheit_to_kelvin</code> that converts temperatures from Fahrenheit to Kelvin.</p>
<pre class="r"><code>fahrenheit_to_kelvin &lt;- function(temp_F) {
  temp_K &lt;- ((temp_F - 32) * (5 / 9)) + 273.15
}</code></pre>
<p>We define <code>fahrenheit_to_kelvin</code> by assigning it to the output of <code>function</code>. The list of argument names are contained within parentheses. Next, the body of the function–the statements that are executed when it runs–is contained within curly braces (<code>{}</code>). The statements in the body are indented by two spaces, which makes the code easier to read but does not affect how the code operates.</p>
<p>When we call the function, the values we pass to it are assigned to those variables so that we can use them inside the function. Let’s try running our function. Calling our own function is no different from calling any other function.</p>
<pre class="r"><code># freezing point of water
fahrenheit_to_kelvin(32)</code></pre>
<pre class="r"><code># boiling point of water
fahrenheit_to_kelvin(212)</code></pre>
<p>We’ve successfully called the function that we defined, and we have access to the value that we returned.</p>
<p>Below is a visualization of a function’s anatomy. The <code>say_hello</code> function takes whatever is placed in the <code>name</code> argument and pastes it with the text “Hello”. Presumably, you’d enter someone’s first name in the <code>say_hello</code> function to have R produce a personalized message. Go ahead and try it out!</p>
<pre class="r"><code>knitr::include_graphics(&quot;Figures/Anatomy of Functions.png&quot;)</code></pre>
<div class="figure">
<img src="Figures/Anatomy%20of%20Functions.png" alt="Dice Function from Grolemund's R for Data Science" width="642" />
<p class="caption">
Dice Function from Grolemund’s R for Data Science
</p>
</div>
<div class="figure">
<img src="Figures/Anatomy%20of%20Functions.png" alt="Anatomy of a function." />
<p class="caption">Anatomy of a function.</p>
</div>
<div id="composing-functions" class="section level2">
<h2>Composing Functions</h2>
<p>Functions can operate on the results of one another, such as <code>f(g(x))</code>. Let’s see how this is done with temperature. Now that we’ve turned Fahrenheit into Kelvin, it’s easy to turn Kelvin into Celsius.</p>
<pre class="r"><code>kelvin_to_celsius &lt;- function(temp_K) {
  temp_K - 273.15
}

# Absolute zero in Celsius
kelvin_to_celsius(0)</code></pre>
<pre><code>## [1] -273.15</code></pre>
<p>What about converting Fahrenheit to Celsius? We could write out the formula, but we don’t need to. Instead, we can compose the two functions we have already created.</p>
<pre class="r"><code>fahrenheit_to_celsius &lt;- function(temp_F) {
  temp_K &lt;- fahrenheit_to_kelvin(temp_F)
  temp_C &lt;- kelvin_to_celsius(temp_K)
  return(temp_C)
}

# freezing point of water in Celsius
fahrenheit_to_celsius(32.0)</code></pre>
<pre><code>## [1] 0</code></pre>
<p>This is our first taste of how larger programs are built: we define basic operations, then combine them in ever-larger chunks to get the effect we want. Real-life functions will usually be larger than the ones shown here–typically half a dozen to a few dozen lines–but they shouldn’t ever be much longer than that, or the next person who reads it won’t be able to understand what’s going on.</p>
<div id="excercise---function" class="section level5">
<h5>Excercise - Function</h5>
<ul>
<li><p>Write a function for calculating the mean</p></li>
<li><p>Write a function</p></li>
</ul>
</div>
</div>
</div>
<div id="apply-and-loops" class="section level1">
<h1>Apply and Loops</h1>
<p><strong>Looping</strong>, <strong>cycling</strong>, <strong>iterating</strong> or just replicating instructions is an old practice that originated well before the invention of computers. It is nothing more than automating a multi-step process by organizing sequences of actions or ‘batch’ processes and by grouping the parts that need to be repeated. All modern programming languages provide special constructs that allow for the repetition of instructions or blocks of instructions.</p>
<p>We will focus on one type of loop construct known as a <code>for</code> loop which executes a function a prescribed number of times, as controlled by a counter or an index, and increments at each iteration cycle. The <code>apply</code> command or rather family of commands, is coded in the R base package and obviates the need to manually program loops. It is populated with a number of functions (the <code>[s,l,m,r, t,v]apply</code>) to manipulate slices of data in the form of matrices or arrays in a repetitive way, allowing to cross or traverse the data and avoiding explicit use of loop constructs. The functions act on an input matrix or array and apply a chosen named function with one or several optional arguments. Note if you have a dataframe all variables must be numeric for <em>apply</em> to work (if not, use <code>sapply</code> or <code>lapply</code> instead).</p>
<p>To demonstrate their application we will simulate depression data for 5 participants measured across 4 timepoints.</p>
<pre class="r"><code>set.seed(1)                                        #replicate results 
Dep &lt;- round(rnorm(20, c(40, 30, 20, 10), 5), 0)   #5 participant scores declining over 4 days
Subjects &lt;- factor(rep(seq(1,5),each=4))           #Create subject factor id
Day &lt;- rep(paste0(&quot;Day&quot;, 1:4), 5)                  #Time label
DepData &lt;- data.frame(Subjects, Day, Dep)          #Combine into dataset

ANOVAresults&lt;-aov(Dep~Day + Error(Subjects/Day), DepData) #Testing whether depression declines
summary(ANOVAresults)</code></pre>
<pre><code>## 
## Error: Subjects
##           Df Sum Sq Mean Sq F value Pr(&gt;F)
## Residuals  4   65.2    16.3               
## 
## Error: Subjects:Day
##           Df Sum Sq Mean Sq F value   Pr(&gt;F)    
## Day        3 1801.3   600.4   31.55 5.66e-06 ***
## Residuals 12  228.4    19.0                     
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<pre class="r"><code>model.tables(ANOVAresults,&quot;means&quot;) #Showing improvement in scores over time</code></pre>
<pre><code>## Tables of means
## Grand mean
##       
## 26.05 
## 
##  Day 
## Day
## Day1 Day2 Day3 Day4 
## 39.8 27.8 23.2 13.4</code></pre>
<pre class="r"><code>DepData &lt;- spread(DepData, Day, Dep) %&gt;% dplyr::select(-Subjects)                  #Tidy data
DepData[2,4] &lt;- NA                                                                 #Add missing cell
print(DepData)</code></pre>
<pre><code>##   Day1 Day2 Day3 Day4
## 1   37   31   16   18
## 2   42   26   22   NA
## 3   43   28   28   12
## 4   37   19   26   10
## 5   40   35   24   13</code></pre>
<p>The data is kept small for ease of understanding. Each cell provides a depression score for each participant taken over the course of a 4-day treatment. Columns represent time and rows represent participants. Also note row 2 column 4 has a missing value which we will address shortly.</p>
<p>To access the help menu, type <code>?apply</code> in the R console. You will see the apply function has four main arguments:</p>
<ol style="list-style-type: decimal">
<li><p><code>X</code> is the object we would like to apply some function to (often a matrix or data frame)</p></li>
<li><p><code>MARGIN</code> specifies whether to apply a function over the rows (indicated by a 1) or columns (indicated by a 2)</p></li>
<li><p><code>FUN</code> is the function we wish to apply</p></li>
<li><p>The <code>...</code> is where we specify any other arguments that need to be passed along to the function we are calling in the <code>apply</code> statement.</p></li>
</ol>
<p>Let’s work through an example. Say we wish to calculate the average amount of depression experienced by all participants on each of the 4 days. We would do the following:</p>
<pre class="r"><code># Calculate mean despression of each day
apply(X = DepData, MARGIN = 2, FUN = mean)</code></pre>
<pre><code>## Day1 Day2 Day3 Day4 
## 39.8 27.8 23.2   NA</code></pre>
<p>Here R has applied the <code>mean</code> function over each column in the depression data set. However, notice Day 4 has returned NA. This is because Day 4 has a missing value for the second participant. To handle this, we must tell R to calculate the mean depression for each day, removing NAs.</p>
<pre class="r"><code>apply(X = DepData, MARGIN = 2, FUN = mean, na.rm = TRUE)</code></pre>
<pre><code>##  Day1  Day2  Day3  Day4 
## 39.80 27.80 23.20 13.25</code></pre>
<p>Note R has four specialized apply function for means and sums (<code>rowSums</code>, <code>colSums</code>, <code>rowMeans</code>, and <code>colMeans</code>) which are faster in operation and simpler in syntax.</p>
<pre class="r"><code>colMeans(DepData, na.rm = T)</code></pre>
<pre><code>##  Day1  Day2  Day3  Day4 
## 39.80 27.80 23.20 13.25</code></pre>
<p>The true power of <code>apply</code> is your ability to deploy any imaginable function across your data. For instance, we can identify the maximum depression level on any given day with the <code>max</code> function.</p>
<pre class="r"><code>apply(DepData, 2, max, na.rm = TRUE)</code></pre>
<pre><code>## Day1 Day2 Day3 Day4 
##   43   35   28   18</code></pre>
<p>Perhaps we wish to find percentiles for the depression scores using the <code>quantile</code> function. Let’s look at the 20th and 80th percentile for each day by sending the additional argument of <code>probs</code>.</p>
<pre class="r"><code>apply(DepData, 2, quantile, probs = c(.20, .80), 
      na.rm = TRUE)</code></pre>
<pre><code>##     Day1 Day2 Day3 Day4
## 20% 37.0 24.6 20.8 11.2
## 80% 42.2 31.8 26.4 15.0</code></pre>
<p>We could also use the <code>apply</code> function to create plots for each column. Below we apply the <code>plot</code> function and pass the additional argument <code>type = "l"</code> to produce a line plot.</p>
<pre class="r"><code> apply(DepData, 2, plot, type = &quot;l&quot;)</code></pre>
<p><img src="Fundamentals_files/figure-html/unnamed-chunk-184-1.png" width="672" /><img src="Fundamentals_files/figure-html/unnamed-chunk-184-2.png" width="672" /><img src="Fundamentals_files/figure-html/unnamed-chunk-184-3.png" width="672" /><img src="Fundamentals_files/figure-html/unnamed-chunk-184-4.png" width="672" /></p>
<pre><code>## NULL</code></pre>
<p>We can add some additional arguments to the plot function to make it more informative, such as title and axis labels. Further, we can modify aesthetics to improve appearance.</p>
<pre class="r"><code> apply(DepData, 2, plot, type = &quot;l&quot;, 
       main = &quot;Dep Treatment&quot;, ylab = &quot;Dep Score&quot;,
       xlab = &quot;Day&quot;, col = &quot;blue&quot;)</code></pre>
<p><img src="Fundamentals_files/figure-html/unnamed-chunk-185-1.png" width="672" /><img src="Fundamentals_files/figure-html/unnamed-chunk-185-2.png" width="672" /><img src="Fundamentals_files/figure-html/unnamed-chunk-185-3.png" width="672" /><img src="Fundamentals_files/figure-html/unnamed-chunk-185-4.png" width="672" /></p>
<pre><code>## NULL</code></pre>
<p>Suppose we wanted to look at the overall amount of depression per participant across days. We can apply functions across data rows by specifying <code>MARGIN = 1</code></p>
<pre class="r"><code>apply(DepData, MARGIN = 1, mean, na.rm = TRUE)</code></pre>
<pre><code>## [1] 25.50 30.00 27.75 23.00 28.00</code></pre>
<p>You can also apply the built-in R function</p>
<pre class="r"><code>rowMeans(DepData, na.rm = TRUE)</code></pre>
<pre><code>## [1] 25.50 30.00 27.75 23.00 28.00</code></pre>
<div id="tapply" class="section level2">
<h2>Tapply</h2>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
